# Setup Memovee

## Model and Processor Setup

```mermaid
graph TD
    A[Global Space] --> B(Source);

    B --> C[Completion Model];
    B --> D[Embedding Model];
    B --> E[Reranking Model];

    G[Completion Processor] --> C;
    G --> A;
    H[Embedding Processor] --> D;
    H --> A;
    I[Reranking Processor] --> E;
    I --> A;
```

The Global Space processors serve as the default process in case each of the space do not have their own configured processor.

<!-- livebook:{"break_markdown":true} -->

We setup the global models that will be used by default.

```elixir
alias Tama.Global
alias Tama.Sensory
alias Tama.Neural
alias Tama.Processors

global_space = Global.space()

arrakis_source = Sensory.get_source(global_space, "arrakis models")

{:ok, arrakis_source} =
  if is_nil(arrakis_source) do
    Sensory.create_source(global_space, %{
      name: "arrakis models",
      type: :model,
      endpoint: "https://models.arrakis.upmaru.network",
      credential: %{
        api_key: "dummy"
      }
    })
  else
    {:ok, arrakis_source}
  end

Sensory.create_limit(arrakis_source, %{scale_unit: :seconds, limit: 32})

nebius_source = Sensory.get_source(global_space, "nebius")

{:ok, nebius_source} =
  if is_nil(nebius_source) do
    Sensory.create_source(global_space, %{
      name: "nebius",
      type: :model,
      endpoint: "https://api.studio.nebius.com",
      credential: %{
        api_key: System.get_env("LB_NEBIUS_API_KEY")
      }
    })
  else
    {:ok, nebius_source}
  end

Sensory.create_limit(nebius_source, %{scale_unit: :seconds, limit: 32})


llama_70b_model = Sensory.get_model(nebius_source, "meta-llama/Llama-3.3-70B-Instruct")

{:ok, llama_70b_model} =
  if is_nil(llama_70b_model) do
    Sensory.create_model(nebius_source, %{
      identifier: "meta-llama/Llama-3.3-70B-Instruct",
      path: "/v1/chat/completions"
    })
  else
    {:ok, llama_70b_model}
  end

google_ai_studio_source = Sensory.get_source(global_space, "google-ai-studio")

{:ok, google_ai_studio_source} =
  if is_nil(google_ai_studio_source) do
    Sensory.create_source(global_space, %{
      name: "google-ai-studio",
      type: :model,
      endpoint: "https://generativelanguage.googleapis.com/v1beta/openai",
      credential: %{
        api_key: System.get_env("LB_GEMINI_API_KEY")
      }
    })
  else
    {:ok, google_ai_studio_source}
  end

gemini_2_flash = Sensory.get_model(google_ai_studio_source, "gemini-2.0-flash")

{:ok, gemini_2_flash} =
  if is_nil(gemini_2_flash) do
    Sensory.create_model(google_ai_studio_source, %{
      identifier: "gemini-2.0-flash",
      path: "/chat/completions"
    })
  else
    {:ok, gemini_2_flash}
  end

gemini_2_5_flash_lite = Sensory.get_model(google_ai_studio_source, "gemini-2.5-flash-lite-preview-06-17")

{:ok, gemini_2_5_flash_lite} =
  if is_nil(gemini_2_5_flash_lite) do
    Sensory.create_model(google_ai_studio_source, %{
      identifier: "gemini-2.5-flash-lite-preview-06-17",
      path: "/chat/completions",
      parameters: %{
        "reasoning_effort" => "none"
      }
    })
  else
    {:ok, gemini_2_5_flash_lite}
  end


gemini_2_5_flash = Sensory.get_model(google_ai_studio_source, "gemini-2.5-flash")

{:ok, gemini_2_5_flash} =
  if is_nil(gemini_2_5_flash) do
    Sensory.create_model(google_ai_studio_source, %{
      identifier: "gemini-2.5-flash",
      path: "/chat/completions",
      parameters: %{
        "reasoning_effort" => "none"
      }
    })
  else
    {:ok, gemini_2_5_flash}
  end

anthropic_source = Sensory.get_source(global_space, "anthropic")

{:ok, anthropic_source} =
  if is_nil(anthropic_source) do
    Sensory.create_source(global_space, %{
      name: "anthropic",
      type: :model,
      endpoint: "https://api.anthropic.com",
      credential: %{
        api_key: System.get_env("LB_ANTHROPIC_API_KEY")
      }
    })
  else
    {:ok, anthropic_source}
  end

Sensory.create_limit(anthropic_source, %{scale_unit: :minutes, limit: 50})

claude_3_5_haiku = Sensory.get_model(anthropic_source, "claude-3-5-haiku-latest")

{:ok, claude_3_5_haiku} =
  if is_nil(claude_3_5_haiku) do
    Sensory.create_model(anthropic_source, %{
      identifier: "claude-3-5-haiku-latest",
      path: "/v1/chat/completions"
    })
  else
    {:ok, claude_3_5_haiku}
  end

xai_source = Sensory.get_source(global_space, "x-ai")

{:ok, xai_source} =
  if is_nil(xai_source) do
    Sensory.create_source(global_space, %{
      name: "x-ai",
      type: :model,
      endpoint: "https://api.x.ai",
      credential: %{
        api_key: System.get_env("LB_XAI_API_KEY")
      }
    })
  else
    {:ok, xai_source}
  end

Sensory.create_limit(xai_source, %{scale_unit: :seconds, limit: 8})

grok_3_mini = Sensory.get_model(xai_source, "grok-3-mini")

{:ok, grok_3_mini} =
  if is_nil(grok_3_mini) do
    Sensory.create_model(xai_source, %{
      identifier: "grok-3-mini",
      path: "/v1/chat/completions",
      parameters: %{
        "reasoning_effort" => "low"
      }
    })
  else
    {:ok, grok_3_mini}
  end

grok_3_mini_fast = Sensory.get_model(xai_source, "grok-3-mini-fast")

{:ok, grok_3_mini_fast} =
  if is_nil(grok_3_mini_fast) do
    Sensory.create_model(xai_source, %{
      identifier: "grok-3-mini-fast",
      path: "/v1/chat/completions",
      parameters: %{
        "reasoning_effort" => "low"
      }
    })
  else
    {:ok, grok_3_mini_fast}
  end

ai21_source = Sensory.get_source(global_space, "ai21")

{:ok, ai21_source} =
  if is_nil(ai21_source) do
    Sensory.create_source(global_space, %{
      name: "ai21",
      type: :model,
      endpoint: "https://api.ai21.com/studio",
      credential: %{
        api_key: System.get_env("LB_AI21_API_KEY")
      }
    })
  else
    {:ok, ai21_source}
  end

jamba_mini = Sensory.get_model(ai21_source, "jamba-mini")

{:ok, jamba_mini} =
  if is_nil(jamba_mini) do
    Sensory.create_model(ai21_source, %{
      identifier: "jamba-mini",
      path: "/v1/chat/completions"
    })
  else
    {:ok, jamba_mini}
  end

jamba_large = Sensory.get_model(ai21_source, "jamba-large")

{:ok, jamba_large} =
  if is_nil(jamba_large) do
    Sensory.create_model(ai21_source, %{
      identifier: "jamba-large",
      path: "/v1/chat/completions"
    })
  else
    {:ok, jamba_large}
  end

azure_source = Sensory.get_source(global_space, "azure-ai-foundry")

{:ok, azure_source} =
  if is_nil(azure_source) do
    Sensory.create_source(global_space, %{
      name: "azure-ai-foundry",
      type: :model,
      endpoint: "https://tama-dev-resource.openai.azure.com/openai/deployments",
      credential: %{
        api_key: System.get_env("LB_AZURE_AI_FOUNDRY_API_KEY")
      }
    })
  else
    {:ok, azure_source}
  end

Sensory.create_limit(azure_source, %{scale_unit: :minutes, limit: 100})

gpt_4_1_mini = Sensory.get_model(azure_source, "gpt-4.1-mini")

{:ok, gpt_4_1_mini} =
  if is_nil(gpt_4_1_mini) do
    Sensory.create_model(azure_source, %{
      identifier: "gpt-4.1-mini",
      path: "/gpt-4.1-mini/chat/completions?api-version=2025-01-01-preview"
    })
  else
    {:ok, gpt_4_1_mini}
  end

gpt_4_1 = Sensory.get_model(azure_source, "gpt-4.1")

{:ok, gpt_4_1} =
  if is_nil(gpt_4_1) do
    Sensory.create_model(azure_source, %{
      identifier: "gpt-4.1",
      path: "/gpt-4.1/chat/completions?api-version=2025-01-01-preview"
    })
  else
    {:ok, gpt_4_1}
  end

gpt_4o_mini = Sensory.get_model(azure_source, "gpt-4o-mini")

{:ok, gpt_4o_mini} =
  if is_nil(gpt_4o_mini) do
    Sensory.create_model(azure_source, %{
      identifier: "gpt-4o-mini",
      path: "/gpt-4o-mini/chat/completions?api-version=2025-01-01-preview"
    })
  else
    {:ok, gpt_4o_mini}
  end

gpt_4_1 = Sensory.get_model(azure_source, "gpt-4.1")

{:ok, gpt_4_1} =
  if is_nil(gpt_4_1) do
    Sensory.create_model(azure_source, %{
      identifier: "gpt-4.1",
      path: "/gpt-4.1/chat/completions?api-version=2025-01-01-preview"
    })
  else
    {:ok, gpt_4_1}
  end

openrouter_source = Sensory.get_source(global_space, "openrouter")

{:ok, openrouter_source} =
  if is_nil(openrouter_source) do
    Sensory.create_source(global_space, %{
      name: "openrouter",
      type: :model,
      endpoint: "https://openrouter.ai/api/v1",
      credential: %{
        api_key: System.get_env("LB_OPENROUTER_API_KEY")
      }
    })
  else
    {:ok, openrouter_source}
  end

openrouter_gpt_4_1_mini = Sensory.get_model(openrouter_source, "openai/gpt-4.1-mini")

{:ok, openrouter_gpt_4_1_mini} =
  if is_nil(openrouter_gpt_4_1_mini) do
    Sensory.create_model(openrouter_source, %{
      identifier: "openai/gpt-4.1-mini",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_gpt_4_1_mini}
  end

openrouter_gemini_2_5_flash = Sensory.get_model(openrouter_source, "google/gemini-2.5-flash")

{:ok, openrouter_gemini_2_5_flash} =
  if is_nil(openrouter_gemini_2_5_flash) do
    Sensory.create_model(openrouter_source, %{
      identifier: "google/gemini-2.5-flash",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_gemini_2_5_flash}
  end

openrouter_gemma3_27b = Sensory.get_model(openrouter_source, "google/gemma-3-27b-it")

{:ok, openrouter_gemma3_27b} =
  if is_nil(openrouter_gemma3_27b) do
    Sensory.create_model(openrouter_source, %{
      identifier: "google/gemma-3-27b-it",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_gemma3_27b}
  end

openrouter_command_a = Sensory.get_model(openrouter_source, "cohere/command-a")

{:ok, openrouter_command_a} =
  if is_nil(openrouter_command_a) do
    Sensory.create_model(openrouter_source, %{
      identifier: "cohere/command-a",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_command_a}
  end

openrouter_gemini_2_5_pro = Sensory.get_model(openrouter_source, "google/gemini-2.5-pro")

{:ok, openrouter_gemini_2_5_pro} =
  if is_nil(openrouter_gemini_2_5_pro) do
    Sensory.create_model(openrouter_source, %{
      identifier: "google/gemini-2.5-pro",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_gemini_2_5_pro}
  end

openrouter_llama4_maverick = Sensory.get_model(openrouter_source, "meta-llama/llama-4-maverick")

{:ok, openrouter_llama4_maverick} =
  if is_nil(openrouter_llama4_maverick) do
    Sensory.create_model(openrouter_source, %{
      identifier: "meta-llama/llama-4-maverick",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_llama4_maverick}
  end

openrouter_qwen3_a22b = Sensory.get_model(openrouter_source, "qwen/qwen3-235b-a22b")

{:ok, openrouter_qwen3_a22b} =
  if is_nil(openrouter_qwen3_a22b) do
    Sensory.create_model(openrouter_source, %{
      identifier: "qwen/qwen3-235b-a22b",
      path: "/chat/completions"
    })
  else
    {:ok, openrouter_qwen3_a22b}
  end

cohere_source = Sensory.get_source(global_space, "cohere")

{:ok, cohere_source} =
  if is_nil(cohere_source) do
    Sensory.create_source(global_space, %{
      name: "cohere",
      type: :model,
      endpoint: "https://api.cohere.ai/compatibility/v1",
      credential: %{
        api_key: System.get_env("LB_COHERE_API_KEY")
      }
    })
  else
    {:ok, cohere_source}
  end

command_a = Sensory.get_model(cohere_source, "command-a-03-2025")

{:ok, command_a} =
  if is_nil(command_a) do
    Sensory.create_model(cohere_source, %{
      identifier: "command-a-03-2025",
      path: "/chat/completions"
    })
  else
    {:ok, command_a}
  end

command_r = Sensory.get_model(cohere_source, "command-r-08-2024")

{:ok, command_r} =
  if is_nil(command_r) do
    Sensory.create_model(cohere_source, %{
      identifier: "command-r-08-2024",
      path: "/chat/completions"
    })
  else
    {:ok, command_r}
  end

mistral_source = Sensory.get_source(global_space, "mistral")

{:ok, mistral_source} =
  if is_nil(mistral_source) do
    Sensory.create_source(global_space, %{
      name: "mistral",
      type: :model,
      endpoint: "https://api.mistral.ai/v1",
      credential: %{
        api_key: System.get_env("LB_MISTRAL_API_KEY")
      }
    })
  else
    {:ok, mistral_source}
  end

mistral_medium = Sensory.get_model(mistral_source, "mistral-medium-2505")

{:ok, mistral_medium} =
  if is_nil(mistral_medium) do
    Sensory.create_model(mistral_source, %{
      identifier: "mistral-medium-2505",
      path: "/chat/completions"
    })
  else
    {:ok, mistral_medium}
  end

codestral = Sensory.get_model(mistral_source, "codestral-2501")

{:ok, codestral} =
  if is_nil(codestral) do
    Sensory.create_model(mistral_source, %{
      identifier: "codestral-2501",
      path: "/chat/completions"
    })
  else
    {:ok, codestral}
  end

mistral_small = Sensory.get_model(mistral_source, "mistral-small-2506")

{:ok, mistral_small} =
  if is_nil(mistral_small) do
    Sensory.create_model(mistral_source, %{
      identifier: "mistral-small-2506",
      path: "/chat/completions"
    })
  else
    {:ok, mistral_small}
  end

model_identifier = "qwen-3-14b"

completion_model = Sensory.get_model(arrakis_source, model_identifier)

{:ok, completion_model} =
  if is_nil(completion_model) do
    Sensory.create_model(arrakis_source, %{
      identifier: model_identifier,
      path: "/v1/chat/completions",
      parameters: %{
        "stream_options" => %{
          "include_usage" => true
        }
      }
    })
  else
    {:ok, completion_model}
  end

completion_processor = Processors.get(global_space, completion_model)

{:ok, completion_processor} =
  if is_nil(completion_processor) do
    Processors.create(global_space, completion_model, %{
      type: :completion,
      configuration: %{
        temperature: 0.8
      }
    })
  else
    {:ok, completion_processor}
  end

embedding_model = Sensory.get_model(arrakis_source, "intfloat/multilingual-e5-large-instruct")

{:ok, embedding_model} =
  if is_nil(embedding_model) do
    Sensory.create_model(arrakis_source, %{
      identifier: "intfloat/multilingual-e5-large-instruct",
      path: "/embeddings"
    })
  else
    {:ok, embedding_model}
  end

embedding_processor = Processors.get(global_space, embedding_model)

{:ok, embedding_processor} =
  if is_nil(embedding_processor) do
    Processors.create(global_space, embedding_model, %{
      type: :embedding,
      configuration: %{
        max_tokens: 512,
        templates: [
          %{
            type: "query",
            content: """
            Instruct: {{ instruction }}
            Query: {{ query }}
            """
          }
        ]
      }
    })
  else
    {:ok, embedding_processor}
  end

reranking_model = Sensory.get_model(arrakis_source, "mixedbread-ai/mxbai-rerank-large-v1")

{:ok, reranking_model} =
  if is_nil(reranking_model) do
    Sensory.create_model(arrakis_source, %{
      identifier: "mixedbread-ai/mxbai-rerank-large-v1",
      path: "/rerank",
    })
  else
    {:ok, reranking_model}
  end

reranking_processor = Processors.get(global_space, reranking_model)

reranking_processor =
  if is_nil(reranking_processor) do
    Processors.create(global_space, reranking_model, %{
      type: :reranking,
      configuration: %{
        top_n: 3
      }
    })
  else
    reranking_processor
  end

context_metadata_class = Global.class!("context-metadata")

template =
  """
  ## Context Metadata:
  ACTOR ID: {{ data.actor_id }}
  CURRENT DATE AND TIME: {{ data.current_timestamp }}
  """

base_context_metadata_corpus = Neural.get_corpus(context_metadata_class, "base-context-metadata")

{:ok, base_context_metadata_corpus} =
  if is_nil(base_context_metadata_corpus) do
    Neural.create_corpus(context_metadata_class, %{
      name: "Base Context Metadata",
      main: true,
      template: template
    })
  else
    {:ok, base_context_metadata_corpus}
  end
```

## Memovee Space

We create the root space that will handle the message processing.

```elixir
alias Tama.Neural
alias Tama.Memory

memovee_space = Neural.get_space(name: "memovee")

{:ok, memovee_space} =
  if is_nil(memovee_space) do
    Neural.create_space(%{name: "memovee", type: :root})
  else
    {:ok, memovee_space}
  end

personality_prompt = Memory.get_prompt(memovee_space, "memovee-system")

{:ok, personality_prompt} =
  if is_nil(personality_prompt) do
    Memory.create_prompt(memovee_space, %{
      name: "Memovee System",
      role: :system,
      content: """
      # Persona
      Your name is 'Memovee'. Act as a friendly, enthusiastic, and knowledgeable movie expert. Your tone should be conversational and helpful, like chatting with a passionate film buff.

      # Core Function
      Your primary purpose is to assist users with a wide range of inquiries about movies, television series, actors, directors, awards, genres, film history, and the entertainment industry.

      # Capabilities
      - Answer factual questions (e.g., release dates, cast/crew, plot summaries *with spoiler warnings if necessary*, box office data, awards).
      - Provide movie/show recommendations based on user preferences (genre, actors, mood, similar titles).
      - Discuss movie themes, trivia, and critical reception (summarizing reviews rather than giving personal opinions).
      - Explain film terminology or concepts.
      - Identify where films/shows might be streaming or available for rent/purchase (use tools for current information).

      # Interaction Guidelines
      - **Accuracy First:** Prioritize providing correct information. If you don't know the answer or cannot verify it, explicitly state that. Avoid speculation.
      - **Clarification:** If a user's request is vague or ambiguous (e.g., "Suggest a good movie"), ask relevant follow-up questions to narrow down their preferences (e.g., "What genres do you usually enjoy?" or "What's a movie you liked recently?").
      - **Tool Usage:** You may have access to tools (like search). Use them strategically when:
          - The information is likely time-sensitive (e.g., current streaming availability, recent news, showtimes).
          - Verifying specific, obscure, or very recent details.
          - You lack the information in your internal knowledge base.
          Clearly indicate if you are using external information.
      - **Spoiler Alert:** Be mindful of spoilers. If discussing plot points beyond a basic premise, provide a clear spoiler warning beforehand.
      - **Stay On-Topic:** Focus your responses on the user's film/TV-related queries. Gently redirect if the conversation strays too far.

      # Constraints
      - Do not express personal opinions as facts. You can cite critical consensus or common viewpoints.
      - Do not provide links to illegal streaming or download sites.
      - Maintain a respectful and appropriate tone at all times.
      """
    })
  else
    {:ok, personality_prompt}
  end
```

## Setup Indexing

We create an `index` schema with a `document` property nested inside. We will create a chain that will use `tama/classes/extraction` on the `document` this will create a separate `index.document` class that we will be able to create entities under when we want to index a document.

```elixir
alias Tama.Sensory
alias Tama.Repo

indexing_space = Neural.get_space(name: "elasticsearch")

{:ok, indexing_space} =
  if is_nil(indexing_space) do
    Neural.create_space(%{name: "elasticsearch", type: :component})
  else
    {:ok, indexing_space}
  end

schema = %{
  "components" => %{
    "security" => [%{"ApiKey" => %{}}],
    "securitySchemes" => %{
      "ApiKey" => %{
        "in" => "header",
        "name" => "Authorization",
        "scheme" => "ApiKey",
        "type" => "apiKey"
      }
    }
  },
  "info" => %{
    "description" => "API for creating indexes and managing aliases in Elasticsearch. Connects to https://elasticsearch.arrakis.upmaru.network",
    "title" => "Elasticsearch Index Creation and Alias API",
    "version" => "1.0.0"
  },
  "openapi" => "3.1.0",
  "paths" => %{
    "/{index}" => %{
      "put" => %{
        "description" => "Creates a new index in Elasticsearch. The index name is determined by the path parameter. Supports specifying settings and mappings.",
        "operationId" => "create-index",
        "parameters" => [
          %{
            "description" => "The name of the index to create. This becomes part of the URL path (e.g., /my_index).",
            "in" => "path",
            "name" => "index",
            "required" => true,
            "schema" => %{"type" => "string"}
          }
        ],
        "requestBody" => %{
          "content" => %{
            "application/json" => %{
              "schema" => %{
                "additionalProperties" => true,
                "title" => "index-creation",
                "description" => "Used for creating elasticsearch index",
                "properties" => %{
                  "aliases" => %{
                    "description" => "Index aliases. Optional.",
                    "type" => "object",
                  },
                  "mappings" => %{
                    "description" => "Index mappings. Optional.",
                    "type" => "object"
                  },
                  "settings" => %{
                    "description" => "Index settings. Optional.",
                    "type" => "object"
                  }
                },
                "type" => "object"
              }
            },
            "required" => false
          }
        },
        "responses" => %{
          "200" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{
                  "properties" => %{
                    "acknowledged" => %{
                      "description" => "True if the index creation was acknowledged.",
                      "type" => "boolean"
                    }
                  },
                  "required" => ["acknowledged"],
                  "type" => "object"
                }
              }
            },
            "description" => "Index created successfully. Returns acknowledgements."
          }
        },
        "summary" => "Create an index"
      }
    },
    "/{index}/_doc/{id}" => %{
      "put" => %{
        "description" => "Creates or updates a document in the specified Elasticsearch index with a custom document ID.",
        "operationId" => "create-or-update-document-with-id",
        "parameters" => [
          %{
            "description" => "The name of the index where the document will be created or updated.",
            "in" => "path",
            "name" => "index",
            "required" => true,
            "schema" => %{"type" => "string"}
          },
          %{
            "description" => "The document ID to be used. If the document already exists, it will be updated.",
            "in" => "path",
            "name" => "id",
            "required" => true,
            "schema" => %{"type" => "string"}
          }
        ],
        "requestBody" => %{
          "content" => %{
            "application/json" => %{
              "title" => "document-body",
              "description" => "The document to be passed in",
              "schema" => %{
                "type" => "object",
                "description" => "The document body to be created or updated."
              }
            }
          },
          "required" => true
        },
        "responses" => %{
          "200" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{
                  "title" => "create-or-update-index-response",
                  "description" => "The expected response when the document is created or updated.",
                  "properties" => %{
                    "_index" => %{"type" => "string"},
                    "_id" => %{"type" => "string"},
                    "_version" => %{"type" => "integer"},
                    "result" => %{"type" => "string"},
                    "_seq_no" => %{"type" => "integer"},
                    "_primary_term" => %{"type" => "integer"}
                  },
                  "type" => "object"
                }
              }
            },
            "description" => "Document created or updated successfully."
          }
        },
        "summary" => "Create or update a document with a custom ID"
      }
    },
    "/_aliases" => %{
      "post" => %{
        "description" => "Updates or adds aliases for Elasticsearch indices.",
        "operationId" => "update-aliases",
        "requestBody" => %{
          "content" => %{
            "application/json" => %{
              "title" => "alias-update-body",
              "description" => "The alias update body to be sent.",
              "schema" => %{
                "type" => "object",
                "description" => "An object specifying the aliases to add or remove.",
                "properties" => %{
                  "actions" => %{
                    "description" => "List of alias actions to perform (e.g., add, remove).",
                    "type" => "array",
                    "items" => %{
                      "type" => "object",
                      "properties" => %{
                        "add" => %{
                          "description" => "Adds an alias to the index.",
                          "type" => "object",
                          "properties" => %{
                            "alias" => %{"type" => "string"},
                            "index" => %{"type" => "string"}
                          },
                          "required" => ["alias", "index"]
                        },
                        "remove" => %{
                          "description" => "Removes an alias from the index.",
                          "type" => "object",
                          "properties" => %{
                            "alias" => %{"type" => "string"},
                            "index" => %{"type" => "string"}
                          },
                          "required" => ["alias", "index"]
                        }
                      }
                    }
                  }
                },
                "required" => ["actions"]
              }
            },
            "required" => true
          }
        },
        "responses" => %{
          "200" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{
                  "properties" => %{
                    "acknowledged" => %{"type" => "boolean"},
                    "success" => %{"type" => "boolean"},
                    "shards_acknowledged" => %{"type" => "boolean"}
                  },
                  "required" => ["acknowledged", "success", "shards_acknowledged"],
                  "type" => "object"
                }
              }
            },
            "description" => "Alias update acknowledged successfully."
          }
        },
        "summary" => "Update or add aliases for indices"
      }
    }
  },
  "servers" => [
    %{
      "description" => "Elasticsearch Server",
      "url" => "https://elasticsearch.arrakis.upmaru.network"
    }
  ]
}

{:ok, elasticsearch_specification} =
  Sensory.Specification
  |> Repo.get_by(space_id: indexing_space.id, endpoint: "https://elasticsearch.arrakis.upmaru.network/openapi")
  |> case do
    nil ->
      Sensory.create_specification(indexing_space, %{
        endpoint: "https://elasticsearch.arrakis.upmaru.network/openapi",
        schema: schema,
        version: "3.1.0"
      })
    %Sensory.Specification{} = elasticsearch_specification ->
      {:ok, elasticsearch_specification}
  end

bot = Tama.Global.bot()

if elasticsearch_specification.current_state == "created" do
  Eventful.Transit.perform(elasticsearch_specification, bot, "process")
end
```

```elixir
%{identities: [identity]} =
  indexing_space
  |> Sensory.get_source!(:repository)
  |> Repo.preload([:identities])

if identity.current_state == "draft" do
  {:ok, identity} = Sensory.update_identity(identity, %{
    "api_key" => System.get_env("LB_ELASTICSEARCH_API_KEY"),
    "validation" => %{
      "path" => "/_cluster/health",
      "method" => "GET",
      "codes" => [200]
    }
  })

  Eventful.Transit.perform(identity, bot, "validate")
end
```

## Create Routing Chain

When the message is passed into the system, we pass the messag through a routing system. This is a classification or similarity based routing. The LLM chooses the path that is most likely to satisfy the request from the user.

```elixir
alias Tama.Global
alias Tama.Perception
alias Tama.Neural

actor_schema = %{
  "title" => "actor",
  "type" => "object",
  "description" => "Actors in a given system",
  "properties" => %{
    "id" => %{
      "type" => "string",
      "description" => "Unique identifier of the actor."
    }
  },
  "required" => ["id"]
}

actor_class = Neural.get_class(memovee_space, "actor")

{:ok, actor_class} =
  if is_nil(actor_class) do
    Neural.create_class(memovee_space, actor_schema)
  else
    {:ok, actor_class}
  end

thread_schema = %{
  "title" => "thread",
  "type" => "object",
  "description" => "A thread of messages.",
  "properties" => %{
    "id" => %{
      "type" => "string",
      "description" => "Unique identifier of the thread."
    },
    "subject" => %{
      "type" => "string",
      "description" => "The subject of the thread.",
      "default" => "Untitled"
    }
  },
  "required" => ["id"]
}

thread_class = Neural.get_class(memovee_space, "thread")

{:ok, thread_class} =
  if is_nil(thread_class) do
    Neural.create_class(memovee_space, thread_schema)
  else
    {:ok, thread_class}
  end

user_message_schema = %{
  "title" => "user-message",
  "type" => "object",
  "description" => "A message from the user",
  "metadata" => %{
    "role" => "user"
  },
  "properties" => %{
    "content" => %{
      "type" => "string",
      "description" => "The main content of the message."
    },
    "index" => %{
      "type" => "integer",
      "description" => "Index of the message in a given thread."
    },
    "thread_id" => %{
      "type" => "string",
      "description" => "Reference to the thread."
    },
    "actor_id" => %{
      "type" => "string",
      "description" => "Foreign key reference for the actor entity."
    }
  },
  "required" => ["content", "index", "actor_id", "thread_id"]
}

user_message_class = Neural.get_class(memovee_space, "user-message")

{:ok, user_message_class} =
  if is_nil(user_message_class) do
    Neural.create_class(memovee_space, user_message_schema)
  else
    {:ok, user_message_class}
  end

Neural.create_corpus(user_message_class, %{
  main: true,
  template: "{{ data.content }}"
})

assistant_message_schema = %{
  "title" => "assistant-message",
  "type" => "object",
  "description" => "A message from the assistant",
  "metadata" => %{
    "role" => "assistant"
  },
  "properties" => %{
    "content" => %{
      "anyOf" => [
        %{"type" => "string"},
        %{"type" => "null"}
      ],
      "description" => "The main content of the message."
    },
    "tool_calls" => %{
      "type" => "array",
      "description" => "An array of tool calls",
      "items" => %{
        "type" => "object",
        "properties" => %{
          "function" => %{
            "type" => "object",
            "properties" => %{
              "arguments" => %{
                "type" => "string",
                "description" => "Arguments passed to the function."
              },
              "description" => %{
                "anyOf" => [
                  %{"type" => "string"},
                  %{"type" => "null"}
                ],
                "description" => "Description of the function."
              },
              "name" => %{
                "type" => "string",
                "description" => "Name of the function."
              }
            },
            "required" => ["arguments", "name"]
          },
          "id" => %{
            "type" => "string",
            "description" => "ID of the tool call."
          },
          "type" => %{
            "type" => "string",
            "description" => "Type of tool call (e.g., function)."
          }
        },
        "required" => ["function", "id", "type"]
      }
    },
    "index" => %{
      "type" => "integer",
      "description" => "Index of the message in a given thread."
    },
    "thread_id" => %{
      "type" => "string",
      "description" => "Reference to the thread."
    },
    "actor_id" => %{
      "type" => "string",
      "description" => "Foreign key reference for the actor entity."
    }
  },
  "required" => ["content", "index", "actor_id", "thread_id"]
}

assistant_message_class = Neural.get_class(memovee_space, "assistant-message")

{:ok, assistant_message_class} =
  if is_nil(assistant_message_class) do
    Neural.create_class(memovee_space, assistant_message_schema)
  else
    {:ok, assistant_message_class}
  end

tool_message_schema = %{
  "title" => "tool-message",
  "type" => "object",
  "description" => "A response from the tool",
  "metadata" => %{
    "role" => "tool"
  },
  "properties" => %{
    "name" => %{
      "type" => "string",
      "description" => "Name of the function call"
    },
    "content" => %{
      "type" => "string",
      "description" => "The main content of the message."
    },
    "tool_call_id" => %{
      "type" => "string",
      "description" => "Reference for the tool call"
    },
    "index" => %{
      "type" => "integer",
      "description" => "Index of the message in a given thread."
    },
    "thread_id" => %{
      "type" => "string",
      "description" => "Reference to the thread."
    },
    "actor_id" => %{
      "type" => "string",
      "description" => "Foreign key reference for the actor entity."
    }
  },
  "required" => ["name", "content", "index", "actor_id", "thread_id", "tool_call_id"]
}

tool_message_class = Neural.get_class(memovee_space, "tool-message")

{:ok, tool_message_class} =
  if is_nil(tool_message_class) do
    Neural.create_class(memovee_space, tool_message_schema)
  else
    {:ok, tool_message_class}
  end

response_schema = %{
  "title" => "response",
  "type" => "object",
  "description" => "Final class to hold entities for final response.",
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The origin entity with the original message"
    },
    "forwarded_from_concept_id" => %{
      "type" => "string",
      "description" => "The concept id that forwarded this message."
    }
  },
  "required" => ["origin_entity_id", "forwarded_from_concept_id"]
}

response_class = Neural.get_class(memovee_space, "response")

{:ok, response_class} =
  if is_nil(response_class) do
    Neural.create_class(memovee_space, response_schema)
  else
    {:ok, response_class}
  end

basic_conversation_space = Neural.get_space(name: "basic-conversation")

{:ok, basic_conversation_space} =
  if is_nil(basic_conversation_space) do
    Neural.create_space(%{name: "Basic Conversation", type: :component})
  else
    {:ok, basic_conversation_space}
  end

# off_topic is like a catch all
off_topic_schema = %{
  "type" => "object",
  "title" => "off-topic",
  "description" => """
  The message is unrelated to any movie, TV show, or the people involved in them; it's neither a greeting nor an introduction.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin entity.",
    }
  },
  "required" => ["origin_entity_id"]
}

off_topic_class = Neural.get_class(basic_conversation_space, "off-topic")

{:ok, off_topic_class} =
  if is_nil(off_topic_class) do
    Neural.create_class(basic_conversation_space, off_topic_schema)
  else
    {:ok, off_topic_class}
  end

greeting_schema = %{
  "type" => "object",
  "title" => "greeting",
  "description" => """
  The message is a greeting. The user is saying hi or greeting us in some way.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin entity.",
    }
  },
  "required" => ["origin_entity_id"]
}

greeting_class = Neural.get_class(basic_conversation_space, "greeting")

{:ok, greeting_class} =
  if is_nil(greeting_class) do
    Neural.create_class(basic_conversation_space, greeting_schema)
  else
    {:ok, greeting_class}
  end

introductory_schema = %{
  "type" => "object",
  "title" => "introductory",
  "description" => """
  The message is an introductory message it contains a name or some personal information.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

introductory_class = Neural.get_class(basic_conversation_space, "introductory")

{:ok, introductory_class} =
  if is_nil(introductory_class) do
    Neural.create_class(basic_conversation_space, introductory_schema)
  else
    {:ok, introductory_class}
  end

# handle curse words
curse_schema = %{
  "type" => "object",
  "title" => "curse",
  "description" => """
  Curse word or inappropriate content.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

curse_class = Neural.get_class(basic_conversation_space, "curse")

{:ok, curse_class} =
  if is_nil(curse_class) do
    Neural.create_class(basic_conversation_space, curse_schema)
  else
    {:ok, curse_class}
  end

media_conversation_space = Neural.get_space(name: "media-conversation")

{:ok, media_conversation_space} =
  if is_nil(media_conversation_space) do
    Neural.create_space(%{name: "Media Conversation", type: :component})
  else
    {:ok, media_conversation_space}
  end

media_detail_schema = %{
  "type" => "object",
  "title" => "media-detail",
  "description" => """
  Queries that reference a specific movie or TV show where a media ID is explicitly provided in the context, and the user is seeking detailed information about that specific title. These queries typically focus on attributes like release date, budget, cast, filming location, plot details, or other specific facts about the named media.

    **Examples:**
    - (With media ID or Title in context for *Titanic*) "When was *Titanic* released?"
    - (With media ID or Title in context for *The Shawshank Redemption*) "What was the budget for *The Shawshank Redemption*?"
    - (With media ID or Title in context for *Jaws*) "Where did *Jaws* take place?"
    - (With media ID or Title in context for *The Little Mermaid*) "What is the runtime of this movie?"
    - (With media ID or Title in context for *Moana 2*) "Who played Maui in Moana 2?" or "Who voiced Sarabi in Mufasa the lion king?"

    **Routing Logic:** Route to `media-detail` when the query explicitly mentions a movie title or TV show title or when a media ID is available in the context and the query seeks specific details about that media.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

media_detail_class = Neural.get_class(media_conversation_space, "media-detail")

{:ok, media_detail_class} =
  if is_nil(media_detail_class) do
    Neural.create_class(media_conversation_space, media_detail_schema)
  else
    {:ok, media_detail_class}
  end

media_browsing_schema = %{
  "type" => "object",
  "title" => "media-browsing",
  "description" => """
  Queries that do not reference a specific movie or TV show by name or media ID and instead seek general information, recommendations, or comparisons about movies or TV shows based on themes, genres, settings, ratings, budgets, or other attributes. These queries are exploratory and often involve lists, categories, or broad inquiries about media without pinpointing a single title.

    **Examples:**
    - "Movies that take place in the sea or the ocean."
    - "What are some highly rated sci-fi movies from the 2000s?"
    - "Which movies had the highest budgets in 2020?"
    - "TV shows about time travel."

    **Routing Logic:** Route to `media-browsing` when the query does not mention a specific title or media ID and focuses on discovering or comparing media based on general criteria or attributes.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

media_browsing_class = Neural.get_class(media_conversation_space, "media-browsing")

{:ok, media_browsing_class} =
  if is_nil(media_browsing_class) do
    Neural.create_class(media_conversation_space, media_browsing_schema)
  else
    {:ok, media_browsing_class}
  end

person_detail_schema = %{
  "type" => "object",
  "title" => "person-detail",
  "description" => """
  User mention specific cast or crew member by their Name or ID  and want to know more about them.

    **Examples:**
    - "Who is Sigourney Weaver?"
    - "What are some movies Sigourney Weaver has been in?"

    **Routing Logic:** Route to `media-detail` when the query explicitly mentions a movie title or TV show title or when a media ID is available in the context and the query seeks specific details about that media.
      **Examples:**
      - "Who played role X in movie Y"
      - "Who voiced X in Y"
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

person_detail_class = Neural.get_class(media_conversation_space, "person-detail")

{:ok, person_detail_class} =
  if is_nil(person_detail_class) do
    Neural.create_class(media_conversation_space, person_detail_schema)
  else
    {:ok, person_detail_class}
  end

person_browsing_schema = %{
  "type" => "object",
  "title" => "person-browsing",
  "description" => """
  User does not mention a specific person but talks about a movie or tv show the person may have been in. Examples: 'Who was the lead actor in the movie [movie name]?' or 'Who produced [movie name]?' or 'Who directed [movie name]?'.
  """,
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin message.",
    }
  },
  "required" => ["origin_entity_id"]
}

person_browsing_class = Neural.get_class(media_conversation_space, "person-browsing")

{:ok, person_browsing_class} =
  if is_nil(person_browsing_class) do
    Neural.create_class(media_conversation_space, person_browsing_schema)
  else
    {:ok, person_browsing_class}
  end

routing_class = Global.class!("message-routing")

forward_message_chain =
  Perception.get_chain(memovee_space, "route-message")
  |> Repo.preload([:thoughts])

classify_prompt = Memory.get_prompt(memovee_space, "classify-message")

{:ok, classify_prompt} =
  if is_nil(classify_prompt) do
    Memory.create_prompt(memovee_space, %{
      name: "Classify Message",
      role: :system,
      content: """
      Classify the last user message into one of the following classes.
      Take into account the previous messages in context.

      --

      Classes:
      {{ classes }}
      """
    })
  else
    {:ok, classify_prompt}
  end

Neural.create_bridge(memovee_space, %{target_space_id: basic_conversation_space.id})

Neural.create_bridge(memovee_space, %{target_space_id: media_conversation_space.id})

entity_network_class = Global.class!("entity-network")

{:ok, %{thoughts: [network_thought, _]} = forward_message_chain} =
  if is_nil(forward_message_chain) do
    Perception.create_chain(memovee_space, %{
      name: "Route Message",
      thoughts: [
        %{
          relation: "network",
          output_class_id: entity_network_class.id,
          module: %{
            reference: "tama/entities/network",
            parameters: %{
              on: ["thread_id", "actor_id"]
            }
          },
          paths: [
            %{target_class_id: thread_class.id},
            %{target_class_id: actor_class.id}
          ]
        },
        %{
          relation: "routing",
          output_class_id: routing_class.id,
          processors: [
            %{
              type: :completion,
              model_id: mistral_small.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          module: %{
            reference: "tama/agentic/router",
            parameters: %{
              similarity: %{
                limit: 10,
                threshold: 0.9
              },
              classification: %{
                schema_template: """

                """
              }
            }
          },
          contexts: [
            %{prompt_id: classify_prompt.id}
          ],
          paths: [
            %{target_class_id: off_topic_class.id},
            %{target_class_id: greeting_class.id},
            %{target_class_id: introductory_class.id},
            %{target_class_id: curse_class.id},
            %{target_class_id: media_detail_class.id},
            %{target_class_id: media_browsing_class.id},
            %{target_class_id: person_detail_class.id},
            %{target_class_id: person_browsing_class.id}
          ]
        }
      ]
    })
  else
    {:ok, forward_message_chain}
  end

Neural.get_or_create_node(
  memovee_space,
  user_message_class,
  forward_message_chain,
  %{type: :reactive}
)

network_message_chain = Perception.get_chain(memovee_space, "network-message")

{:ok, network_message_chain} =
  if is_nil(network_message_chain) do
    Perception.create_chain(memovee_space, %{
      name: "Network Message",
      thoughts: [
        %{
          delegation: %{target_thought_id: network_thought.id}
        }
      ]
    })
  else
    {:ok, network_message_chain}
  end

Neural.get_or_create_node(
  memovee_space,
  tool_message_class,
  network_message_chain,
  %{type: :reactive}
)

Neural.get_or_create_node(
  memovee_space,
  assistant_message_class,
  network_message_chain,
  %{type: :reactive}
)

```

## Setup Embed User Message

We want to be able to get vector embeddings of the messages passed in. There are high chances that we do not need to use 'classify' every time and we can just do routing based on similarity. It will be faster.

```elixir
alias Tama.Repo

answer_class =
  Global.class!("answer")
  |> Repo.preload([:main_corpus])

embed_basic_message_chain =
  Perception.get_chain(basic_conversation_space, "embed-user-message")
  |> Repo.preload([:thoughts])

{:ok, %{thoughts: [extraction_thought, embed_thought]} = embed_basic_message_chain} =
  if is_nil(embed_basic_message_chain) do
    Perception.create_chain(basic_conversation_space, %{
      name: "Embed User Message",
      thoughts: [
        %{
          relation: "extraction",
          module: %{
            reference: "tama/entities/extraction",
            parameters: %{
              relations: ["content"]
            }
          }
        },
        %{
          relation: "embed",
          module: %{
            reference: "tama/concepts/embed",
            parameters: %{
              relation: "content"
            },
            input: %{
              type: :concept,
              class_corpus_id: answer_class.main_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, embed_basic_message_chain}
  end

Neural.get_or_create_node(
  basic_conversation_space,
  greeting_class,
  embed_basic_message_chain,
  %{type: :reactive}
)

Neural.get_or_create_node(
  basic_conversation_space,
  introductory_class,
  embed_basic_message_chain,
  %{type: :reactive}
)

embed_media_message_chain =
  Perception.get_chain(media_conversation_space, "embed-user-message")
  |> Repo.preload([:thoughts])

{:ok, embed_media_message_chain} =
  if is_nil(embed_media_message_chain) do
    Perception.create_chain(media_conversation_space, %{
      name: "Embed User Message",
      thoughts: [
        %{delegation: %{target_thought_id: extraction_thought.id}},
        %{delegation: %{target_thought_id: embed_thought.id}}
      ]
    })
  else
    {:ok, embed_media_message_chain}
  end

Neural.get_or_create_node(
  media_conversation_space,
  media_detail_class,
  embed_media_message_chain,
  %{type: :reactive}
)

Neural.get_or_create_node(
  media_conversation_space,
  media_browsing_class,
  embed_media_message_chain,
  %{type: :reactive}
)

Neural.get_or_create_node(
  media_conversation_space,
  person_detail_class,
  embed_media_message_chain,
  %{type: :reactive}
)

Neural.get_or_create_node(
  media_conversation_space,
  person_browsing_class,
  embed_media_message_chain,
  %{type: :reactive}
)
```

## Setup Prompt Assembly

The Prompt assembly space is where everything comes together. The reason for this space is so that. We can do final processing and decision making before asking the model to creat a reply to the user.

This is useful because we may have a multi-step message like the following:

```
Hi there! Can you find all the movies by Tom Hanks and sort it by ratings. The best movies come first in the list, for each movie can you also please find out who the directors are.
```

This is an example of a multi-intent message where the system will need to break down the problem into 3 steps.

1. Search for Tom Hanks
2. Find all the movies he's been in
3. Sort the movies by decending ratings
4. For each of the movies find out who the directors are
5. Finally compose a reply from all the data

As the model is traversing each of the steps each of the steps will have their own objectives and context, we need to reduce that to one final context. In this case it maybe that the greeting is less relevant but focusing on the objectives of searching for the resources is more important.

```elixir
prompt_assembly_space = Neural.get_space(name: "Prompt Assembly")

{:ok, prompt_assembly_space} =
  if is_nil(prompt_assembly_space) do
    Neural.create_space(%{
      name: "Prompt Assembly", type: :component
    })
  else
    {:ok, prompt_assembly_space}
  end

context_component_schema = %{
  "type" => "object",
  "title" => "context-component",
  "description" => """
  The component to be used in the generation of the final prompt.
  """,
  "properties" => %{
    "forwarded_from_concept_id" => %{
      "type" => "string",
      "description" => "The ID of the concept forwarded to this class"
    }
  },
  "required" => ["forwarded_from_concept_id"]
}

context_component_class = Neural.get_class(prompt_assembly_space, "context-component")

{:ok, context_component_class} =
  if is_nil(context_component_class) do
    Neural.create_class(prompt_assembly_space, context_component_schema)
  else
    {:ok, context_component_class}
  end
```

## Setup Personalization

We need to setup the personalization space to allow Memovee to be able to store the user's profile. When the user shares information about themselves Memovee will use this space to record the details.

````elixir
alias Tama.Repo

schema = %{
  "components" => %{
    "schemas" => %{
      "Error" => %{
        "description" => "Error response schema",
        "properties" => %{
          "code" => %{"description" => "The error code", "type" => "string"},
          "message" => %{
            "description" => "The error message",
            "type" => "string"
          }
        },
        "required" => ["message", "code"],
        "type" => "object"
      },
      "Profile" => %{
        "description" => """
        Profile for a given actor in a system.

        ## Important
        - DO NOT use empty values like "" instead simply do not include the keys if you do not have a value.
        """,
        "properties" => %{
          "dates" => %{
            "items" => %{
              "properties" => %{
                "index" => %{"type" => "integer"},
                "significance" => %{
                  "enum" => ["wedding", "birth", "start_school", "graduated"],
                  "type" => "string"
                },
                "value" => %{"format" => "date", "type" => "string"}
              },
              "required" => ["index", "significance", "value"],
              "type" => "object"
            },
            "type" => "array"
          },
          "gender" => %{
            "description" => "This is required default to `other` if not provided.",
            "enum" => ["male", "female", "other"],
            "type" => "string"
          },
          "names" => %{
            "description" => """
            The names of the actor.

            A Name like 'Zack Siri' will be split into the following structure:

            ```json
            [
              {"index": 0, "group": "real", "value": "Zack"},
              {"index": 1, "group": "real", "value": "Siri"}
            ]
            ```

            If the user specifically mentioned "you can call me 'Zack'" or something along this line it should be recorded as:

            ```json
            [
              {"index": 0, "group": "real", "value": "Zack"},
              {"index": 1, "group": "real", "value": "Siri"},
              {"index": 0, "group": "callable", "value": "Zack"}
            ]
            ```
            """,
            "items" => %{
              "properties" => %{
                "group" => %{"enum" => ["callable", "real"], "type" => "string"},
                "index" => %{"type" => "integer"},
                "value" => %{"type" => "string"}
              },
              "required" => ["index", "value"],
              "type" => "object"
            },
            "type" => "array"
          },
          "pronoun" => %{
            "description" => "This is required default to `other` if not provided.",
            "enum" => ["he/him", "she/her", "they/them", "other"],
            "type" => "string"
          }
        },
        "required" => ["names"],
        "title" => "profile",
        "type" => "object"
      }
    }
  },
  "info" => %{
    "description" => "API for personalization data.",
    "title" => "Personalization API",
    "version" => "1.0.0"
  },
  "openapi" => "3.1.0",
  "paths" => %{
    "/profile/{actor_id}" => %{
      "get" => %{
        "description" => "Returns the profile for a given actor in a system.",
        "operationId" => "get-profile",
        "parameters" => [
          %{
            "description" => "The ID of the entity",
            "in" => "path",
            "name" => "actor_id",
            "required" => true,
            "schema" => %{"type" => "string"}
          }
        ],
        "responses" => %{
          "200" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{"$ref" => "#/components/schemas/Profile"}
              }
            },
            "description" => "A profile object"
          },
          "404" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{"$ref" => "#/components/schemas/Error"}
              }
            },
            "description" => "Entity not found"
          }
        },
        "summary" => "Get profile for a given actor in a system",
        "tags" => ["Personalization"]
      },
      "put" => %{
        "description" => """
        Create or update the profile for a given actor in a system.
        """,
        "operationId" => "create-or-update-profile",
        "parameters" => [
          %{
            "description" => "The ID of the actor",
            "in" => "path",
            "name" => "actor_id",
            "required" => true,
            "schema" => %{"type" => "string"}
          }
        ],
        "requestBody" => %{
          "content" => %{
            "application/json" => %{
              "schema" => %{"$ref" => "#/components/schemas/Profile"}
            }
          },
          "required" => true
        },
        "responses" => %{
          "200" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{"$ref" => "#/components/schemas/Profile"}
              }
            },
            "description" => "Profile updated successfully"
          },
          "404" => %{
            "content" => %{
              "application/json" => %{
                "schema" => %{"$ref" => "#/components/schemas/Error"}
              }
            },
            "description" => "Entity not found"
          }
        },
        "summary" => """
        Create or update the profile for a given actor in a system.

        ## Important
        - DO NOT use empty values like "" instead simply do not include the keys if you do not have a value.
        """,
        "tags" => ["Personalization"]
      }
    }
  },
  "servers" => [
    %{
      "description" => "Internal Personalization Endpoint",
      "url" => "/internal/personalization"
    }
  ]
}

personalization_space = Neural.get_space(name: "personalization")

{:ok, personalization_space} =
  if is_nil(personalization_space) do
    Neural.create_space(%{name: "personalization", type: :component})
  else
    {:ok, personalization_space}
  end

Neural.create_bridge(memovee_space, %{target_space_id: personalization_space.id})

{:ok, specification} =
  Sensory.Specification
  |> Repo.get_by(space_id: personalization_space.id, endpoint: "/internal/personalization/openapi")
  |> case do
    nil ->
      Sensory.create_specification(personalization_space, %{
        endpoint: "/internal/personalization/openapi",
        schema: schema,
        version: "3.1.0"
      })
    %Sensory.Specification{} = specification ->
      {:ok, specification}
  end

bot = Tama.Global.bot()

if specification.current_state == "created" do
  Eventful.Transit.perform(specification, bot, "process")
end
````

## Setup Conversation Chains

This is how we setup a basic conversation chain. This example is a greeting chain. When the users greets the model we can define the protocol for handling greeting.

```elixir
alias Tama.Perception

basic_conversation_space = Neural.get_space(name: "basic-conversation")
prompt_assembly_space = Neural.get_space(name: "prompt-assembly")

context_component_class = Neural.get_class(prompt_assembly_space, "context-component")

check_profile_prompt = Memory.get_prompt(basic_conversation_space, "check-profile")

{:ok, check_profile_prompt} =
  if is_nil(check_profile_prompt) do
    Memory.create_prompt(basic_conversation_space, %{
      name: "Check Profile",
      role: :system,
      content: ~S"""
      The user has greeted you
      You are a curious friendly bot that needs to get to know the user.
      You are provided with some tools that will give you the ability to load the user's profile.

      ## Objectives
      - Check if the actor has a profile with a name.
      - Use the tool to load the profile.

      --

      {{ corpus }}
      """
    })
  else
    {:ok, check_profile_prompt}
  end

load_profile_and_greet_chain = Perception.get_chain(basic_conversation_space, "load-profile-and-greet")

get_profile_action =
  Repo.get_by(Tama.Motor.Action, method: :get, path: "/profile/{actor_id}")

Neural.create_bridge(basic_conversation_space, %{target_space_id: prompt_assembly_space.id})

greet_and_reply_prompt = Memory.get_prompt(basic_conversation_space, "greeting-reply")


{:ok, greet_and_reply_prompt} =
  if is_nil(greet_and_reply_prompt) do
    Memory.create_prompt(basic_conversation_space, %{
      name: "Greeting Reply",
      role: :system,
      content: ~S"""
      ## User Greeting Protocol
      1. **Check for User Profile:** Check the conversation to see if you can find the user profile.
      2. **Handle the Result:**
      *  **If Profile Found:** A profile with the user's name (e.g., "Sarah") is returned by the tool.
           * **Action:** Greet the user warmly by name and smoothly transition towards your primary function. Example: "Welcome back, Sarah! How can I assist you with movie and tv show, related questions today?"
      *  **If Profile Not Found:** The tool indicates no profile exists or fails to return a name.
           * **Action:** Politely introduce yourself and ask for the user's name. Example: "Hello there! I'm Memovee, your helpful assistant for all things movie related. I don't think we have a profile for you yet. May I ask your name so we can get to know each other?"
      """
    })
  else
    {:ok, greet_and_reply_prompt}
  end

Neural.create_bridge(basic_conversation_space, %{target_space_id: personalization_space.id})

{:ok, load_profile_and_greet_chain} =
  if is_nil(load_profile_and_greet_chain) do
    Perception.create_chain(basic_conversation_space, %{
      name: "Load Profile and Greet",
      type: :entity,
      thoughts: [
        %{
          relation: "tooling",
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          contexts: [
            %{
              prompt_id: check_profile_prompt.id,
              inputs: [%{type: :metadata, class_corpus_id: base_context_metadata_corpus.id}]
            }
          ],
          tools: [
            %{action_id: get_profile_action.id}
          ],
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: greet_and_reply_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, load_profile_and_greet_chain}
  end

{:ok, _} =
  Neural.get_or_create_node(
    basic_conversation_space,
    greeting_class,
    load_profile_and_greet_chain,
    %{type: :reactive}
  )

```

## Setup Context Assembly Chain

The `Context Assembly` chain will wait for all parts of the message to be processed before assembling the final context prompt that will be passed to the reply generation.

```elixir
prompt_assembly_space = Neural.get_space(name: "prompt-assembly")

response_message_class = Neural.get_class(memovee_space, "response")

context_assembly_chain = Perception.get_chain(prompt_assembly_space, "context-assembly")

Neural.create_bridge(prompt_assembly_space, %{target_space_id: memovee_space.id})

{:ok, context_assembly_chain} =
  if is_nil(context_assembly_chain) do
    Perception.create_chain(prompt_assembly_space, %{
      name: "Context Assembly",
      type: :entity,
      thoughts: [
        %{
          type: :task,
          relation: "merge",
          module: %{
            reference: "tama/contexts/merge",
            parameters: %{}
          }
        },
        %{
          type: :task,
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward",
            parameters: %{}
          },
          paths: [
            %{target_class_id: response_message_class.id}
          ]
        }
      ]
    })
  else
    {:ok, context_assembly_chain}
  end

Neural.get_or_create_node(
  prompt_assembly_space,
  context_component_class,
  context_assembly_chain,
  %{type: :reactive}
)

```

## Setup Reply Chain

```elixir
reply_prompt = Memory.get_prompt(memovee_space, "reply-template")

{:ok, reply_prompt} =
  if is_nil(reply_prompt) do
    Memory.create_prompt(memovee_space, %{
      name: "Reply Template",
      role: :system,
      content: """
      {{ corpus }}

      **General Guidelines:**
      * Maintain a polite and welcoming tone throughout.
      * The transition to the primary objective should feel natural after the greeting.
      * Do not hallucinate, if you do not have the information in context, inform the user accordingly.
      """
    })
  else
    {:ok, reply_prompt}
  end

reply_generation_chain = Perception.get_chain(memovee_space, "reply-generation")

{:ok, reply_generation_chain} =
  if is_nil(reply_generation_chain) do
    Perception.create_chain(memovee_space, %{
      name: "Reply Generation",
      type: :entity,
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/reply", parameters: %{}
          },
          relation: "reply",
          processors: [
            %{
              type: :completion,
              model_id: mistral_small.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          contexts: [
            %{
              prompt_id: personality_prompt.id
            },
            %{
              prompt_id: reply_prompt.id,
              inputs: [
                %{
                  type: :metadata,
                  class_corpus_id: base_context_metadata_corpus.id
                }
              ]
            }
          ]
        }
      ]
    })
  else
    {:ok, reply_generation_chain}
  end

Neural.get_or_create_node(
  memovee_space,
  response_class,
  reply_generation_chain,
  %{type: :reactive}
)

```

## Setup Introductory Chain

The 'introductory' class and chains are made for handling messages that are regarded as 'introductory' in nature. They're messages like "My name is Zack Siri", "You can call me Zack", "I am 40 years old" etc...

The agent will record the details provided by the user.

```elixir
create_or_update_profile_prompt = Memory.get_prompt(basic_conversation_space, "create-or-update-profile")

{:ok, create_or_update_profile_prompt} =
  if is_nil(create_or_update_profile_prompt) do
    Memory.create_prompt(basic_conversation_space, %{
      name: "Create or Update Profile",
      role: :system,
      content: ~S"""
      You have been provided with personal information from the user. Your task is to securely and accurately record this data by interacting with the profile management system.

      ## Objectives
      - Call the appropriate endpoint to create or update the user's profile.
      - Pass only the valid, non-empty data provided by the user to the profile endpoint.

      ## Instructions
      - Ensure all data is validated before submission to avoid errors.
      - Only include key-value pairs in the request body for which the user has provided non-empty, valid values.
        - Example: If the user does not provide a value for `gender`, exclude the `gender` key from the request body.
        - Example: If the user does not provide a value for `pronoun`, exclude the `pronoun` key from the request body.
      - Do not include empty strings (e.g., `""`), null values, or undefined fields in the request body.
      - If the user provides invalid or incomplete data for a field, skip that field and proceed with valid fields only.
      - Handle any errors gracefully and provide clear feedback to the user if the profile creation or update fails.

      --

      {{ corpus }}
      """
    })
  else
    {:ok, create_or_update_profile_prompt}
  end

create_or_update_profile_chain =
  Perception.get_chain(basic_conversation_space, "create-or-update-profile-and-respond")

create_or_update_profile_action =
  Repo.get_by(Tama.Motor.Action, method: :put, path: "/profile/{actor_id}")

profile_update_prompt = Memory.get_prompt(basic_conversation_space, "profile-create-or-update")

{:ok, profile_update_prompt} =
  if is_nil(profile_update_prompt) do
    Memory.create_prompt(basic_conversation_space, %{
      name: "Profile Create or Update",
      role: :system,
      content: ~S"""
      ## User Profile Create or Update Protocol
      1. **Handle Successful Profile Creation or Update:**
      * **If Profile has a Name:** The profile now has the user's name
          * **Action:** Greet the user warmly by name and smoothly transition towards your primary function. Example: "Nice to meet you Zack!, How can I assist you with movie and tv show, related questions today?"

      2. **Handle Profile Create or Update Error:**
      * **If the profile could not be created or updated:**
          * **Action:** Inform the user that the profile could not be updated. If the error response provides information related to the user input inform the user why the input does not work.
      """
    })
  else
    {:ok, profile_update_prompt}
  end

{:ok, create_or_update_profile_chain} =
  if is_nil(create_or_update_profile_chain) do
    Perception.create_chain(basic_conversation_space, %{
      name: "Create or Update Profile and Respond",
      type: :entity,
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          relation: "tooling",
          contexts: [
            %{
              prompt_id: create_or_update_profile_prompt.id,
              inputs: [
                %{type: :metadata, class_corpus_id: base_context_metadata_corpus.id}
              ]
            }
          ],
          tools: [
            %{action_id: create_or_update_profile_action.id}
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: profile_update_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, create_or_update_profile_chain}
  end

Neural.get_or_create_node(
  basic_conversation_space,
  introductory_class,
  create_or_update_profile_chain,
  %{type: :reactive}
)

```

## Setup Movie DB

```elixir
movie_db_space = Neural.get_space(name: "movie-db")

{:ok, movie_db_space} =
  if is_nil(movie_db_space) do
    Neural.create_space(%{name: "movie-db", type: :component})
  else
    {:ok, movie_db_space}
  end

prepare_class_chain = Perception.get_chain(global_space, "prepare-class")
class_proxy_class = Global.class!("class-proxy")

{:ok, _node} = Neural.get_or_create_node(movie_db_space, class_proxy_class, prepare_class_chain, %{type: :reactive})

url = "https://developer.themoviedb.org/openapi/64542913e1f86100738e227f"

tmdb_specification = Sensory.get_specification(movie_db_space, url)

{:ok, tmdb_specification} =
  if is_nil(tmdb_specification) do
    Sensory.create_specification(movie_db_space, url)
  else
    {:ok, tmdb_specification}
  end

bot = Tama.Global.bot()

if tmdb_specification.current_state == "created" do
  Eventful.Transit.perform(tmdb_specification, bot, "process")
end
```

The below schema is for querying the elasticsearch index

```elixir
schema = %{
  "openapi" => "3.1.0",
  "info" => %{
    "title" => "Elasticsearch Search API",
    "description" => "API for searching documents in Elasticsearch. Connects to https://elasticsearch.arrakis.upmaru.network",
    "version" => "1.0.0"
  },
  "servers" => [%{
    "description" => "Elasticsearch Server",
    "url" => "https://elasticsearch.arrakis.upmaru.network"
  }],
  "components" => %{
    "securitySchemes" => %{
      "ApiKey" => %{
        "type" => "apiKey",
        "in" => "header",
        "scheme" => "ApiKey",
        "name" => "Authorization"
      }
    },
    "schemas" => %{
      "text-based-vector-search" => %{
        "title" => "text-based-vector-search",
        "description" => """
        Performs a semantic vector search on an Elasticsearch index using a text-based query. This schema is ideal for queries where understanding the contextual meaning of the text is critical, such as natural language searches. The search leverages vector embeddings and semantic reranking to prioritize results based on meaning rather than exact keyword matches.
        """,
        "type" => "object",
        "properties" => %{
          "query" => %{
            "type" => "string",
            "description" => "A string containing the search text. Required."
          },
          "limit" => %{
            "type" => "integer",
            "description" => "Limit how many results to return. Optional. Defaults to 3."
          },
          "_source" => %{
            "type" => "array",
            "items" => %{"type" => "string"},
            "description" => "An array of field names (strings) to include in the response. Required to limit returned fields for efficiency."
          }
        },
        "required" => ["query", "_source"]
      },
      "query-and-sort-based-search" => %{
        "title" => "query-and-sort-based-search",
        "description" => """
        Executes a structured Elasticsearch query with sorting and filtering capabilities. Use this schema for precise searches, such as matching specific IDs, date ranges, keywords, or combining conditions, with customizable sorting and field selection.
        """,
        "type" => "object",
        "properties" => %{
          "query" => %{
            "type" => "object",
            "description" => "An object defining the search criteria (e.g., `terms`, `range`, `match`, or `bool` queries). Required."
          },
          "limit" => %{
            "type" => "integer",
            "description" => "Limit how many results to return. Optional. Defaults to 3."
          },
          "sort" => %{
            "type" => "array",
            "items" => %{"type" => "object"},
            "description" => "An array of objects specifying fields to sort by and their order. Optional."
          },
          "_source" => %{
            "type" => "array",
            "items" => %{"type" => "string"},
            "description" => "An array of field names (strings) to include in the response. Required to optimize response size."
          }
        },
        "required" => ["query", "_source"]
      },
      "search-response" => %{
        "title" => "search-response",
        "description" => """
        Represents the response from an Elasticsearch search query, containing metadata and search results.
        """,
        "type" => "object",
        "properties" => %{
          "took" => %{
            "type" => "integer",
            "description" => "Integer indicating the time (in milliseconds) the search took to execute."
          },
          "timed_out" => %{
            "type" => "boolean",
            "description" => "Boolean indicating if the search timed out (true/false)."
          },
          "_shards" => %{
            "type" => "object",
            "description" => "Object with shard statistics (`total`, `successful`, `skipped`, `failed`) for query execution.",
            "properties" => %{
              "total" => %{"type" => "integer"},
              "successful" => %{"type" => "integer"},
              "skipped" => %{"type" => "integer"},
              "failed" => %{"type" => "integer"}
            },
            "required" => ["total", "successful", "skipped", "failed"]
          },
          "hits" => %{
            "type" => "object",
            "properties" => %{
              "total" => %{
                "type" => "object",
                "description" => "Object with `value` (number of matching documents) and `relation` (e.g., 'eq' for exact count).",
                "properties" => %{
                  "value" => %{"type" => "integer"},
                  "relation" => %{"type" => "string"}
                },
                "required" => ["value", "relation"]
              },
              "max_score" => %{
                "type" => "number",
                "description" => "Number representing the highest relevance score of the results."
              },
              "hits" => %{
                "type" => "array",
                "description" => "Array of matching documents, each with `_index` (index name), `_id` (document ID), `_score` (relevance score), and `_source` (selected fields).",
                "items" => %{
                  "type" => "object",
                  "properties" => %{
                    "_index" => %{"type" => "string"},
                    "_id" => %{"type" => "string"},
                    "_score" => %{"type" => "number"},
                    "_source" => %{"type" => "object"}
                  }
                }
              }
            }
          }
        },
        "required" => ["took", "timed_out", "_shards", "hits"]
      }
    }
  },
  "paths" => %{
    "/{index}/_search" => %{
      "post" => %{
        "description" => "Searches documents in the specified Elasticsearch index using a query body.",
        "operationId" => "search-index",
        "parameters" => [%{
          "description" => "The name of the index to search. This becomes part of the URL path (e.g., /my_index).",
          "in" => "path",
          "name" => "index",
          "required" => true,
          "schema" => %{"type" => "string"}
        }],
        "requestBody" => %{
          "description" => "The search query to be executed. Supports both text-based vector search and search with sorting.",
          "content" => %{
            "application/json" => %{
              "schema" => %{
                "oneOf" => [
                  %{"$ref" => "#/components/schemas/text-based-vector-search"},
                  %{"$ref" => "#/components/schemas/query-and-sort-based-search"}
                ]
              }
            }
          },
          "required" => true
        },
        "responses" => %{
          "200" => %{
            "description" => "Search results from Elasticsearch.",
            "content" => %{
              "application/json" => %{
                "schema" => %{"$ref" => "#/components/schemas/search-response"}
              }
            }
          }
        },
        "summary" => "Search documents in an index"
      }
    }
  },
  "security" => [%{"ApiKey" => []}]
}

{:ok, specification} =
  Sensory.Specification
  |> Repo.get_by(space_id: movie_db_space.id, endpoint: "https://elasticsearch.arrakis.upmaru.network/openapi")
  |> case do
    nil ->
      Sensory.create_specification(movie_db_space, %{
        endpoint: "https://elasticsearch.arrakis.upmaru.network/openapi",
        schema: schema,
        version: "3.1.0"
      })
    %Sensory.Specification{} = specification ->
      {:ok, specification}
  end

bot = Tama.Global.bot()

if specification.current_state == "created" do
  Eventful.Transit.perform(specification, bot, "process")
end
```

```elixir
tmdb_source = Repo.get_by(Tama.Sensory.Source, slug: "tmdb-api")
Sensory.create_limit(tmdb_source, %{scale_unit: :seconds, limit: 40})
```

Next we need to setup the Extract Movie credits chain that will extract the array values into their own class for the movie-credits class. We will need to use `Eventful.Transit.perform(entity, bot, "process")` because as the class is being created from above the Extract Movie Credits chain did not exist yet.

```elixir
global_space = Tama.Global.space()

class_proxy_class =
  Neural.get_class!(global_space, "class-proxy")

movie_credit_class =
  Neural.get_class!(movie_db_space, "movie-credits")
  |> Repo.preload([proxy: [:entity]])

extract_movie_credits = Perception.get_chain(movie_db_space, "extract-nested-properties")

{:ok, extract_movie_credits} =
  if is_nil(extract_movie_credits) do
    Perception.create_chain(movie_db_space, %{
      name: "Extract Nested Properties",
      thoughts: [
        %{
          relation: "extraction",
          module: %{
            reference: "tama/classes/extraction",
            parameters: %{
              types: ["array"],
              depth: 1
            }
          },
          paths: [
            %{target_class_id: movie_credit_class.id}
          ]
        }
      ]
    })
  else
    {:ok, extract_movie_credits}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    class_proxy_class,
    extract_movie_credits,
    %{type: :explicit}
  )

bot = Tama.Global.bot()

movie_credit_class.proxy.entity
|> Eventful.Transit.perform(bot, "process", parameters: %{
  chain_ids: [extract_movie_credits.id]
})
```

## Setup identity

```elixir
alias Tama.Sensory

%{identities: [identity]} =
  movie_db_space
  |> Sensory.get_source("tmdb-api")
  |> Repo.preload([:identities])

if identity.current_state == "draft" do
  {:ok, identity} =
    Sensory.update_identity(identity, %{
      "api_key" => System.get_env("LB_TMDB_API_KEY"),
      "validation" => %{
        "path" => "/3/authentication",
        "method" => "GET",
        "codes" => [200]
      }
    })

  Eventful.Transit.perform(identity, bot, "validate")
end

%{identities: [identity]} =
  movie_db_space
  |> Sensory.get_source("elasticsearch-search-api")
  |> Repo.preload([:identities])

if identity.current_state == "draft" do
  {:ok, identity} =
    Sensory.update_identity(identity, %{
      "api_key" => System.get_env("LB_ELASTICSEARCH_READ_API_KEY"),
      "validation" => %{
        "path" => "/_cluster/health",
        "method" => "GET",
        "codes" => [200]
      }
    })

  Eventful.Transit.perform(identity, bot, "validate")
end
```

## Setup Crawling

```elixir
alias Tama.Motor

movie_detail_class =
  Neural.get_class!(movie_db_space, "movie-details")
  |> Repo.preload([:main_corpus])


movie_detail_crawl = Neural.get_corpus(movie_detail_class, "movie-detail-crawl")

{:ok, movie_detail_crawl} =
  if is_nil(movie_detail_crawl) do
    Neural.create_corpus(movie_detail_class, %{
      name: "Movie Detail Crawl",
      template: """
      {
        "path": {
          "movie_id": {{ data.id }}
        },
        "query": {}
      }
      """
    })
  else
    {:ok, movie_detail_crawl}
  end

action_call_class = Global.class!("action-call")

action_call_corpus = Neural.get_corpus(action_call_class, "action-call-json")

{:ok, action_call_corpus} =
  if is_nil(action_call_corpus) do
    Neural.create_corpus(action_call_class, %{
      name: "Action Call JSON",
      template: """
      {{ data | json }}
      """
    })
  else
    {:ok, action_call_corpus}
  end


movie_credit_action = Motor.get_action(movie_db_space, method: :get, path: "/3/movie/{movie_id}/credits")

crawl_movie_credits_chain = Perception.get_chain(movie_db_space, "crawl-movie-credits")

{:ok, crawl_movie_credits_chain} =
  if is_nil(crawl_movie_credits_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Crawl Movie Credits",
      type: :entity,
      thoughts: [
        %{
          relation: "crawl-movie-credits",
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: movie_detail_crawl.id
            }
          },
          tools: [
            %{action_id: movie_credit_action.id}
          ]
        },
        %{
          relation: "movie-credits-response",
          module: %{
            reference: "tama/actions/response",
            parameters: %{
              relation: "crawl-movie-credits",
              identifier: "id",
              validate_record: false,
              process: true
            },
            input: %{
              type: :concept,
              class_corpus_id: action_call_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, crawl_movie_credits_chain}
  end

Neural.get_or_create_node(
  movie_db_space,
  movie_detail_class,
  crawl_movie_credits_chain,
  %{type: :reactive}
)

person_action = Motor.get_action(movie_db_space, method: :get, path: "/3/person/{person_id}")

movie_credits_class =
  Neural.get_class!(movie_db_space, "movie-credits")
  |> Repo.preload([:main_corpus])

movie_credits_crew_class =
  Neural.get_class!(movie_db_space, "movie-credits.crew")
  |> Repo.preload([:main_corpus])

person_detail_crew_crawl_corpus = Neural.get_corpus(movie_credits_crew_class, "person-detail-crew-crawl")

{:ok, person_detail_crew_crawl_corpus} =
  if is_nil(person_detail_crew_crawl_corpus) do
    Neural.create_corpus(movie_credits_crew_class, %{
      name: "Person Detail Crew Crawl",
      template: """
      {
        "path": {
          "person_id": {{ data.id }}
        },
        "query": {}
      }
      """
    })
  else
    {:ok, person_detail_crew_crawl_corpus}
  end

movie_credits_cast_class =
  Neural.get_class!(movie_db_space, "movie-credits.cast")
  |> Repo.preload([:main_corpus])

person_detail_cast_crawl_corpus = Neural.get_corpus(movie_credits_cast_class, "person-detail-cast-crawl")

{:ok, person_detail_cast_crawl_corpus} =
  if is_nil(person_detail_cast_crawl_corpus) do
    Neural.create_corpus(movie_credits_cast_class, %{
      name: "Person Detail Cast Crawl",
      template: """
      {
        "path": {
          "person_id": {{ data.id }}
        },
        "query": {}
      }
      """
    })
  else
    {:ok, person_detail_cast_crawl_corpus}
  end

expand_cast_crew_chain = Perception.get_chain(movie_db_space, "spread-cast-and-crew")

{:ok, expand_cast_crew_chain} =
  if is_nil(expand_cast_crew_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Spread Cast and Crew",
      thoughts: [
        %{
          relation: "spread",
          module: %{
            reference: "tama/entities/spread",
            parameters: %{
              fields: ["cast", "crew"],
              identifier: "id"
            }
          },
          paths: [
            %{target_class_id: movie_credits_crew_class.id},
            %{target_class_id: movie_credits_cast_class.id}
          ]
        }
      ]
    })
  else
    {:ok, expand_cast_crew_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_credits_class,
    expand_cast_crew_chain,
    %{type: :reactive}
  )

network_cast_and_crew_chain = Perception.get_chain(movie_db_space, "network-cast-and-crew")

{:ok, network_cast_and_crew_chain} =
  if is_nil(network_cast_and_crew_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Network Cast and Crew",
      type: :entity,
      thoughts: [
        %{
          relation: "network",
          output_class_id: entity_network_class.id,
          module: %{
            reference: "tama/entities/network",
            parameters: %{
              on: ["parent_entity_id"]
            }
          },
          paths: [
            %{target_class_id: movie_credits_class.id}
          ]
        }
      ]
    })
  else
    {:ok, network_cast_and_crew_chain}
  end

{:ok, _node} = Neural.get_or_create_node(
  movie_db_space,
  movie_credits_crew_class,
  network_cast_and_crew_chain,
  %{type: :reactive}
)

{:ok, _node} = Neural.get_or_create_node(
  movie_db_space,
  movie_credits_cast_class,
  network_cast_and_crew_chain,
  %{type: :reactive}
)

network_credit_chain = Perception.get_chain(movie_db_space, "network-movie-credit")

{:ok, network_credit_chain} =
  if is_nil(network_credit_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Network Movie Credit",
      type: :entity,
      thoughts: [
        %{
          relation: "network",
          output_class_id: entity_network_class.id,
          module: %{
            reference: "tama/entities/network",
            parameters: %{
              on: ["parent_entity_id"]
            }
          },
          paths: [
            %{target_class_id: movie_detail_class.id}
          ]
        }
      ]
    })
  else
    {:ok, network_credit_chain}
  end


{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_credits_class,
    network_credit_chain,
    %{type: :reactive}
  )


crawl_person_cast_chain =
  Perception.get_chain(movie_db_space, "crawl-person-detail-from-cast")
  |> Repo.preload([:thoughts])

{:ok, %{thoughts: [_, response_thought]} = crawl_person_cast_chain} =
  if is_nil(crawl_person_cast_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Crawl Person Detail from Cast",
      thoughts: [
        %{
          relation: "crawl-person-details",
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: person_detail_cast_crawl_corpus.id
            }
          },
          tools: [
            %{action_id: person_action.id}
          ]
        },
        %{
          relation: "person-details-response",
          module: %{
            reference: "tama/actions/response",
            parameters: %{
              relation: "crawl-person-details",
              identifier: "id",
              validate_record: false,
              process: true
            },
            input: %{
              type: :concept,
              class_corpus_id: action_call_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, crawl_person_cast_chain}
  end


{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_credits_cast_class,
    crawl_person_cast_chain,
    %{type: :reactive}
  )

crawl_person_crew_chain = Perception.get_chain(movie_db_space, "crawl-person-detail-from-crew")

{:ok, crawl_person_crew_chain} =
  if is_nil(crawl_person_crew_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Crawl Person Detail from Crew",
      thoughts: [
        %{
          relation: "crawl-person-details",
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: person_detail_crew_crawl_corpus.id
            }
          },
          tools: [
            %{action_id: person_action.id}
          ]
        },
        %{
          delegation: %{target_thought_id: response_thought.id}
        }
      ]
    })
  else
    {:ok, crawl_person_crew_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_credits_crew_class,
    crawl_person_crew_chain,
    %{type: :reactive}
  )

network_person_chain = Perception.get_chain(movie_db_space, "network-person-detail")

{:ok, network_person_chain} =
  if is_nil(network_person_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Network Person Detail",
      thoughts: [
        %{
          relation: "network",
          output_class_id: entity_network_class.id,
          module: %{
            reference: "tama/entities/network",
            parameters: %{
              on: ["parent_entity_id"]
            }
          },
          paths: [
            %{target_class_id: movie_credits_crew_class.id},
            %{target_class_id: movie_credits_cast_class.id}
          ]
        }
      ]
    })
  else
    {:ok, network_person_chain}
  end

person_detail_class = Neural.get_class!(movie_db_space, "person-details")

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_detail_class,
    network_person_chain,
    %{type: :reactive}
  )



```

### Crawl Person Movie Credits

```elixir
person_combined_credits_action = Motor.get_action(movie_db_space, method: :get, path: "/3/person/{person_id}/combined_credits")
person_details_class = Neural.get_class!(movie_db_space, "person-details")

person_crawl_corpus = Neural.get_corpus(person_details_class, "person-crawl")

{:ok, person_crawl_corpus} =
  if is_nil(person_crawl_corpus) do
    Neural.create_corpus(person_details_class, %{
      name: "Person Crawl",
      template: """
      {
        "path": {
          "person_id": {{ data.id }}
        },
        "query": {}
      }
      """
    })
  else
    {:ok, person_crawl_corpus}
  end

crawl_person_credits_chain =
  Perception.get_chain(movie_db_space, "crawl-person-credits")

{:ok, crawl_person_credits_chain} =
  if is_nil(crawl_person_credits_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Crawl Person Credits",
      thoughts: [
        %{
          relation: "crawl-person-combined-credits",
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: person_crawl_corpus.id
            }
          },
          tools: [
            %{action_id: person_combined_credits_action.id}
          ]
        },
        %{
          relation: "person-credits-response",
          module: %{
            reference: "tama/actions/response",
            parameters: %{
              relation: "crawl-person-combined-credits",
              identifier: "id",
              validate_record: false
            },
            input: %{
              type: :concept,
              class_corpus_id: action_call_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, crawl_person_credits_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_detail_class,
    crawl_person_credits_chain,
    %{type: :reactive}
  )

```

```elixir
network_person_credits_chain = Perception.get_chain(movie_db_space, "network-person-credits")
person_credits_class = Neural.get_class!(movie_db_space, "person-combined-credits")

{:ok, network_person_credits_chain} =
  if is_nil(network_person_credits_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Network Person Credits",
      thoughts: [
        %{
          relation: "network",
          output_class_id: entity_network_class.id,
          module: %{
            reference: "tama/entities/network",
            parameters: %{
              on: ["parent_entity_id"]
            }
          },
          paths: [
            %{target_class_id: person_detail_class.id},
          ]
        }
      ]
    })
  else
    {:ok, network_person_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_credits_class,
    network_person_credits_chain,
    %{type: :reactive}
  )

```

## Embed Movie Overview and Person Biography

```elixir
embed_movie_overview_chain = Perception.get_chain(movie_db_space, "embed-movie-overview")

{:ok, embed_movie_overview_chain} =
  if is_nil(embed_movie_overview_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Embed Movie Overview",
      thoughts: [
        %{
          relation: "extraction",
          module: %{
            reference: "tama/entities/extraction",
            parameters: %{
              relations: ["overview"]
            }
          }
        },
        %{
          relation: "embed",
          module: %{
            reference: "tama/concepts/embed",
            parameters: %{
              relation: "overview"
            },
            input: %{
              type: :concept,
              class_corpus_id: answer_class.main_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, embed_movie_overview_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_detail_class,
    embed_movie_overview_chain,
    %{type: :reactive}
  )

embed_person_biography_chain = Perception.get_chain(movie_db_space, "embed-person-biography")

{:ok, embed_person_biography_chain} =
  if is_nil(embed_person_biography_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Embed Person Biography",
      thoughts: [
        %{
          relation: "extraction",
          module: %{
            reference: "tama/entities/extraction",
            parameters: %{
              relations: ["biography"]
            }
          }
        },
        %{
          relation: "embed",
          module: %{
            reference: "tama/concepts/embed",
            parameters: %{
              relation: "biography"
            },
            input: %{
              type: :concept,
              class_corpus_id: answer_class.main_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, embed_person_biography_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_detail_class,
    embed_person_biography_chain,
    %{type: :reactive}
  )
```

## Generate and Embed Movie Description

```elixir
movie_description_generation_prompt = Memory.get_prompt(movie_db_space, "movie-description-generation")

{:ok, movie_description_generation_prompt} =
  if is_nil(movie_description_generation_prompt) do
    Memory.create_prompt(movie_db_space, %{
      name: "Movie Description Generation",
      role: :user,
      content: ~S"""
      Write an accurate description of the movie in a single paragraph. Use as many data fields in the description as you see fit.

      --

      {{ corpus }}
      """
    })
  else
    {:ok, movie_description_generation_prompt}
  end

movie_location_extraction_prompt = Memory.get_prompt(movie_db_space, "movie-location-extraction")

{:ok, movie_location_extraction_prompt} =
  if is_nil(movie_location_extraction_prompt) do
    Memory.create_prompt(movie_db_space, %{
      name: "Movie Location Extraction",
      role: :user,
      content: ~S"""
      Make a best estimate based on the description below on the type of setting the movie is likely to take place, whether it takes place in space, forest, jungle, tundra, desert, in the ocean, or futuristic city, urban environment etc...?

      --

      {{ corpus }}
      """
    })
  else
    {:ok, movie_location_extraction_prompt}
  end

setting_schema = %{
  "properties" => %{
    "locations" => %{
      "description" => "Potential locations the movie takes place.",
      "items" => %{"type" => "string"},
      "type" => "array"
    },
    "reason" => %{
      "description" => "A brief description of the reason why the model thinks the movie took place in those locations.",
      "type" => "string"
    }
  },
  "required" => ["locations", "reason"],
  "title" => "movie-setting",
  "description" => "Details for the setting of the movie.",
  "type" => "object"
}

{:ok, location_output_class} = Neural.get_or_create_class(movie_db_space, setting_schema)

location_class_corpus = Neural.get_corpus(location_output_class, "location-reason")

{:ok, location_class_corpus} =
  if is_nil(location_class_corpus) do
    Neural.create_corpus(location_output_class, %{
      name: "Location Reason",
      main: true,
      template: "{{ data.reason }}"
    })
  else
    {:ok, location_class_corpus}
  end

embed_movie_description_chain = Perception.get_chain(movie_db_space, "embed-movie-description")

{:ok, embed_movie_description_chain} =
  if is_nil(embed_movie_description_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Embed Movie Description",
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/generate",
            parameters: %{}
          },
          relation: "description",
          contexts: [
            %{
              prompt_id: movie_description_generation_prompt.id,
              inputs: [
                %{type: :entity, class_corpus_id: movie_detail_class.main_corpus.id}
              ]
            }
          ]
        },
        %{
          module: %{
            reference: "tama/agentic/generate",
            parameters: %{}
          },
          relation: "setting",
          output_class_id: location_output_class.id,
          contexts: [
            %{
              prompt_id: movie_location_extraction_prompt.id,
              inputs: [
                %{type: :concept, class_corpus_id: answer_class.main_corpus.id}
              ]
            }
          ]
        },
        %{
          relation: "embed",
          module: %{
            reference: "tama/concepts/embed",
            parameters: %{
              relation: "description"
            },
            input: %{
              type: :concept,
              class_corpus_id: answer_class.main_corpus.id
            }
          }
        },
        %{
          relation: "embed",
          module: %{
            reference: "tama/concepts/embed",
            parameters: %{
              relation: "setting"
            },
            input: %{
              type: :concept,
              class_corpus_id: location_class_corpus.id
            }
          }
        }
      ]
    })
  else
    {:ok, embed_movie_description_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_detail_class,
    embed_movie_description_chain,
    %{type: :reactive}
  )

```

## Setup Movie / Person Indexing

This section will setup the indexing chains for the movie

```elixir
alias Tama.Motor.Action


indexing_space = Neural.get_space(name: "elasticsearch")

{:ok, _} =
  if bridge = Neural.get_bridge(movie_db_space, indexing_space) do
    {:ok, bridge}
  else
    Neural.create_bridge(movie_db_space, %{target_space_id: indexing_space.id})
  end


movie_detail_class =
  Neural.get_class!(movie_db_space, "movie-details")
  |> Repo.preload(proxy: [:entity])

template =
  """
  {
    "path": {
      "index": "tama-{{ data.metadata.space }}-{{ data.metadata.class }}",
      "id": "{{ data.id }}"
    },
    "body": {{ data | json }}
  }
  """

movie_detail_index_corpus = Neural.get_corpus(movie_detail_class, "movie-detail-index")

{:ok, movie_detail_index_corpus} =
  if is_nil(movie_detail_index_corpus) do
    Neural.create_corpus(movie_detail_class, %{
      name: "Movie Detail Index",
      template: template
    })
  else
    {:ok, movie_detail_index_corpus}
  end

action = Repo.get_by(Action, specification_id: elasticsearch_specification.id, path: "/{index}/_doc/{id}")

index_movie_detail = Perception.get_chain(movie_db_space, "index-movie-detail")

{:ok, index_movie_detail} =
  if is_nil(index_movie_detail) do
    Perception.create_chain(movie_db_space, %{
      name: "Index Movie Detail",
      thoughts: [
        %{
          relation: "index",
          initializers: [
            %{
              reference: "tama/initializers/preload",
              class_id: movie_detail_class.id,
              parameters: %{
                concept: %{
                  relations: ["description", "overview", "setting"],
                  embeddings: :include,
                  content: %{
                    action: :merge,
                    merge: %{
                      location: :root
                    }
                  }
                },
                children: [
                  %{class: "movie-credits", as: :object}
                ]
              }
            }
          ],
          module: %{
            reference: "tama/actions/caller", parameters: %{},
            input: %{
              type: :entity, class_corpus_id: movie_detail_index_corpus.id
            }
          },
          tools: [
            %{action_id: action.id}
          ]
        }
      ]
    })
  else
    {:ok, index_movie_detail}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_detail_class,
    index_movie_detail,
    %{type: :explicit}
  )

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    movie_detail_class,
    index_movie_detail,
    %{type: :reactive, on: "processed"}
  )

person_detail_class =
  Neural.get_class!(movie_db_space, "person-details")
  |> Repo.preload(proxy: [:entity])

template =
  """
  {
    "path": {
      "index": "tama-{{ data.metadata.space }}-{{ data.metadata.class }}",
      "id": "{{ data.id }}"
    },
    "body": {{ data | json }}
  }
  """

person_detail_index_corpus = Neural.get_corpus(person_detail_class, "person-detail-index")

{:ok, person_detail_index_corpus} =
  if is_nil(person_detail_index_corpus) do
    Neural.create_corpus(person_detail_class, %{
      name: "Person Detail Index",
      template: template
    })
  else
    {:ok, person_detail_index_corpus}
  end

index_person_detail = Perception.get_chain(movie_db_space, "index-person-detail")

{:ok, index_person_detail} =
  if is_nil(index_person_detail) do
    Perception.create_chain(movie_db_space, %{
      name: "Index Person Detail",
      thoughts: [
        %{
          relation: "index",
          initializers: [
            %{
              reference: "tama/initializers/preload",
              class_id: person_detail_class.id,
              parameters: %{
                record: %{
                  rejections: [
                    %{element: :value, matches: [""]}
                  ]
                },
                concept: %{
                  relations: ["biography"],
                  embeddings: :include,
                  content: %{
                    action: :merge,
                    merge: %{
                      location: :root
                    }
                  }
                },
                children: [
                  %{
                    class: "person-combined-credits",
                    as: :object,
                    record: %{
                      rejections: [
                        %{element: :value, matches: [""]}
                      ]
                    }
                  }
                ]
              }
            }
          ],
          module: %{
            reference: "tama/actions/caller", parameters: %{},
            input: %{
              type: :entity, class_corpus_id: person_detail_index_corpus.id
            }
          },
          tools: [
            %{action_id: action.id}
          ]
        }
      ]
    })
  else
    {:ok, index_person_detail}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_detail_class,
    index_person_detail,
    %{type: :explicit}
  )

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    person_detail_class,
    index_person_detail,
    %{type: :reactive, on: "processed"}
  )

task_result_class = Global.class!("task-result")

index_entities = Perception.get_chain(movie_db_space, "index-entities")

{:ok, index_entities} =
  if is_nil(index_entities) do
    Perception.create_chain(movie_db_space, %{
      name: "Index Entities",
      thoughts: [
        %{
          relation: "index",
          output_class_id: task_result_class.id,
          module: %{
            reference: "tama/classes/process",
            parameters: %{}
          },
          paths: [
            %{
              target_class_id: movie_detail_class.id,
              activations: [
                %{chain_id: index_movie_detail.id}
              ]
            },
            %{
              target_class_id: person_detail_class.id,
              activations: [
                %{chain_id: index_person_detail.id}
              ]
            }
          ]
        }
      ]
    })
  else
    {:ok, index_entities}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    class_proxy_class,
    index_entities,
    %{type: :reactive, on: "processed"}
  )

```

## Generate Index Definition

The index definition has the following example structure:

```json
{
  "index": "tama-movie-db-movie-details",
  "definitions": [
    {"property": "id", "description": "The unique id", "type": "long"}
  ]
}
```

Essentially it includes everything we want to pass into the context at tooling time. So the LLM knows which properties to request when building the search query. The `type` will also inform the LLM which fields it can search using `range` or `sort`

````elixir
collection_class =
  Global.class!("collection")
  |> Repo.preload([:main_corpus])

template =
  """
  ---
  collection:
    name: {{ data.name }}
    space: {{ data.space }}

  Sample:
  {{ data.items | json }}
  """

collection_corpus = Neural.get_corpus(collection_class, "sample-items")

{:ok, collection_corpus} =
  if is_nil(collection_corpus) do
    Neural.create_corpus(collection_class, %{
      name: "Sample Items",
      main: true,
      template: template
    })
  else
    {:ok, collection_corpus}
  end

elasticsearch_mapping_schema = %{
  "title" => "elasticsearch-mapping",
  "description" => "For generating elasticsearch index mapping",
  "properties" => %{
    "mappings" => %{
      "type" => "object",
      "description" => "The Elasticsearch mapping for the data."
    }
  },
  "type" => "object",
  "strict" => false,
  "required" => ["mappings"]
}

elasticsearch_mapping_class = Neural.get_class(indexing_space, "elasticsearch-mapping")

{:ok, elasticsearch_mapping_class} =
  if is_nil(elasticsearch_mapping_class) do
    Neural.create_class(indexing_space, elasticsearch_mapping_schema)
  else
    {:ok, elasticsearch_mapping_class}
  end

elasticsearch_mapping_template =
  """
  Mapping:
  {{ data | json }}
  """

elasticsearch_mapping_corpus = Neural.get_corpus(elasticsearch_mapping_class, "elasticsearch-mapping")

{:ok, elasticsearch_mapping_corpus} =
  if is_nil(elasticsearch_mapping_corpus) do
    Neural.create_corpus(elasticsearch_mapping_class, %{
      name: "Elasticsearch Mapping",
      template: elasticsearch_mapping_template
    })
  else
    {:ok, elasticsearch_mapping_corpus}
  end


index_definition_generation_prompt = Memory.get_prompt(movie_db_space, "index-definition-generation")

{:ok, index_definition_generation_prompt} =
  if is_nil(index_definition_generation_prompt) do
    Memory.create_prompt(movie_db_space, %{
      name: "Index Definition Generation",
      role: :system,
      content: ~S"""
      **Task**: Generate an Elasticsearch index name and property definitions based on the provided sample data and Elasticsearch mapping.

      **Index Name Generation**:
      - Extract `collection.space` and `collection.name` from the `collection`.
      - Join the values with a hyphen (`-`) to form the index name in the format: `tama-<collection.space>-<collection.name>`.
      - Ensure the final index name is lowercase.

      **Property Definitions**:
      - ONLY use data from sample data `Samples` for property definition.
      - Generate **one definition per property** in the sample data, including all nested properties, regardless of depth.
      - Use **dot notation** for nested properties (e.g., `metadata.space`, `director.name.first`).
      - Retrieve the `type` for each property from the provided Elasticsearch mapping.
      - For multi-field properties (e.g., a property with `text` and `keyword` subfields), use the **primary `type`** from the mapping (not the subfield type).
      - If a property exists in the sample data but is not found in the mapping, assign it a type of `"unknown"`.
      - For each definition, include:
        - `property`: The full property path using dot notation.
        - `description`: A concise, meaningful description of the propertys purpose, inferred from the field name and sample data. Avoid generic phrases like "A property of the item."
        - `type`: The Elasticsearch type from the mapping or `"unknown"` if not specified.

      - **Handling Nested Objects and Arrays**:
        - For **nested objects**, include all sub-properties using dot notation, even if deeply nested.
        - For **arrays of objects**, include the properties of the first object in the array, using dot notation (e.g., `tags.name` for `tags: [{"name": "Sci-fi"}]`).
        - If a nested field in the sample data has no value (e.g., null or empty), include it only if it is explicitly defined in the mapping.
        - If a field is defined in the mapping but absent in the sample data, **do not include it** in the definitions.

      **Output Format**:
      Return a JSON object with:
      - `index`: The generated index name.
      - `definitions`: An array of definitions, each containing `property`, `description`, and `type`.

      **Validation Rules**:
      - Ensure **all properties** in the sample data are accounted for in the `definitions` array, including nested fields.
      - Validate that the index name follows the format `tama-<space>-<class>` and is lowercase.
      - Ensure descriptions are specific, context-aware, and based on the sample data and field names.
      - If a propertys type is `"unknown"`, include a note in the description indicating it was not found in the mapping.

      **Example**:

      **Input**:
      - Sample:
        ```yaml
        [{
          "metadata": {
            "space": "entertainment",
            "class": "movie"
          },
          "id": 1,
          "title": "Jurassic Park",
          "tags": [{"name": "Sci-fi"}, {"name": "Action"}],
          "category": {
            "name": "Fiction"
          },
          "director": {
            "name": {
              "first": "Steven",
              "last": "Spielberg"
            }
          },
          "extra": "unmapped"
        }]
        ```
      - Mapping:
        ```json
        {
          "mappings": {
            "properties": {
              "metadata": {
                "properties": {
                  "space": {"type": "keyword"},
                  "class": {"type": "keyword"}
                }
              },
              "id": {"type": "long"},
              "title": {
                "type": "text",
                "fields": {
                  "keyword": {"type": "keyword"}
                }
              },
              "tags": {
                "type": "nested",
                "properties": {
                  "name": {"type": "keyword"}
                }
              },
              "category": {
                "properties": {
                  "name": {"type": "keyword"}
                }
              },
              "director": {
                "properties": {
                  "name": {
                    "properties": {
                      "first": {"type": "keyword"},
                      "last": {"type": "keyword"}
                    }
                  }
                }
              }
            }
          }
        }
        ```

      **Output**:
      ```json
      {
        "index": "tama-entertainment-movie",
        "definitions": [
          {
            "property": "metadata.space",
            "description": "The domain or context of the item, e.g., 'entertainment'.",
            "type": "keyword"
          },
          {
            "property": "metadata.class",
            "description": "The category or type of the item, e.g., 'movie'.",
            "type": "keyword"
          },
          {
            "property": "id",
            "description": "A unique identifier for the item, e.g., 1.",
            "type": "long"
          },
          {
            "property": "title",
            "description": "The title of the item, e.g., 'Jurassic Park'.",
            "type": "text"
          },
          {
            "property": "tags.name",
            "description": "A tag describing the item, e.g., 'Sci-fi' or 'Action'.",
            "type": "keyword"
          },
          {
            "property": "category.name",
            "description": "The category of the item, e.g., 'Fiction'.",
            "type": "keyword"
          },
          {
            "property": "director.name.first",
            "description": "The first name of the director, e.g., 'Steven'.",
            "type": "keyword"
          },
          {
            "property": "director.name.last",
            "description": "The last name of the director, e.g., 'Spielberg'.",
            "type": "keyword"
          },
          {
            "property": "extra",
            "description": "An additional field not defined in the mapping, e.g., 'unmapped'.",
            "type": "unknown"
          }
        ]
      }
      ```

      ---

      {{ corpus }}


      **Additional Notes**:
      - Always make sure the "index" value is derived from tama-<collection.space>-<collection.name>
      - Process the sample data and mapping exhaustively to ensure **no properties are skipped**, including nested fields.
      - Use the sample data to inform descriptions but rely on the mapping for accurate type information.
      - If the sample data contains multiple documents, use the first document for generating definitions and the index name.
      - Handle edge cases explicitly:
        - Missing `metadata` object: Use `"unknown"` for both `space` and `class`.
        - Empty arrays or objects: Include only properties defined in the mapping.
        - Properties in sample data but not in mapping: Assign `"unknown"` type and note in description.
      """
    })
  else
    {:ok, index_definition_generation_prompt}
  end


index_defintion_schema = %{
  "title" => "index-definition",
  "description" => "Index definition for elasticsearch mappings",
  "type" => "object",
  "properties" => %{
    "index" => %{
      "type" => "string",
      "description" => "The name of the index"
    },
    "definitions" => %{
      "type" => "array",
      "description" => "The property definition, and their types",
      "items" => %{
        "type" => "object",
        "properties" => %{
          "property" => %{
            "type" => "string"
          },
          "description" => %{
            "type" => "string"
          },
          "type" => %{
            "type" => "string"
          }
        },
        "required" => ["property", "description", "type"]
      }
    }
  },
  "required" => ["index", "definitions"]
}

index_definition_class = Neural.get_class(movie_db_space, "index-definition")

{:ok, index_definition_class} =
  if is_nil(index_definition_class) do
    Neural.create_class(movie_db_space, index_defintion_schema)
  else
    {:ok, index_definition_class}
  end

index_definition_corpus_template =
  """
  Index Definition:
  {{ data | yaml }}
  """

index_definition_corpus = Neural.get_corpus(index_definition_class, "index-definition-yaml")

{:ok, index_definition_corpus} =
  if is_nil(index_definition_corpus) do
    Neural.create_corpus(index_definition_class, %{
      name: "Index Definition YAML",
      template: index_definition_corpus_template
    })
  else
    {:ok, index_definition_corpus}
  end


index_definition_generation = Perception.get_chain(movie_db_space, "index-definition-generation")

{:ok, index_definition_generation} =
  if is_nil(index_definition_generation) do
    Perception.create_chain(movie_db_space, %{
      name: "Index Definition Generation",
      thoughts: [
        %{
          relation: "index-definition",
          initializers: [
            %{
              reference: "tama/initializers/import",
              class_id: class_proxy_class.id,
              parameters: %{
                resources: [
                  %{type: :concept, relation: "mappings", scope: :flow},
                  %{type: :concept, relation: "sample", scope: :flow}
                ]
              }
            }
          ],
          output_class_id: index_definition_class.id,
          module: %{
            reference: "tama/agentic/generate",
            parameters: %{}
          },
          paths: [
            %{
              target_class_id: movie_detail_class.id,
              parameters: %{
                relation: "movie-details-definition"
              }
            },
            %{
              target_class_id: person_detail_class.id,
              parameters: %{
                relation: "person-details-definition"
              }
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: grok_3_mini.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          contexts: [
            %{
              prompt_id: index_definition_generation_prompt.id,
              inputs: [
                %{type: :concept, class_corpus_id: collection_corpus.id},
                %{type: :concept, class_corpus_id: elasticsearch_mapping_corpus.id}
              ]
            }
          ]
        }
      ]
    })
  else
    {:ok, index_definition_generation}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    class_proxy_class,
    index_definition_generation,
    %{type: :reactive, on: "processed"}
  )
````

## Index Mapping Generation

````elixir
alias Tama.Motor.Action


movie_detail_class =
  Neural.get_class!(movie_db_space, "movie-details")

index_generation_schema = %{
  "title" => "index-generation",
  "description" => "For generating elasticsearch index",
  "properties" => %{
    "origin_entity_id" => %{
      "type" => "string",
      "description" => "The ID of the origin entity"
    },
    "forwarded_from_concept_id" => %{
      "type" => "string",
      "description" => "The ID of the concept forwarded to this class"
    },
    "messages" => %{
      "type" => "array",
      "items" => %{
        "type" => "object",
        "properties" => %{
          "role" => %{
            "type" => "string",
            "description" => "The role of the message (e.g., 'user', 'assistant')"
          },
          "content" => %{
            "type" => "string",
            "description" => "The content of the message"
          }
        },
        "required" => ["role", "content"]
      }
    }
  },
  "required" => ["origin_entity_id", "forwarded_from_concept_id", "messages"]
}


generate_movie_db_index_prompt = Memory.get_prompt(movie_db_space, "generate-index-for-movie-db-class")

{:ok, generate_movie_db_index_prompt} =
  if is_nil(generate_movie_db_index_prompt) do
    Memory.create_prompt(movie_db_space, %{
      name: "Generate Index for Movie DB Class",
      role: :user,
      content: ~S"""
      ## Movie DB Specific Constraints
      - The ID should be of the type `long`.
      - Make sure that the following fields are of type `text`:
        - `title`
        - `original_title`
        - `overview`
        - `movie-credits.cast.character`
        - `movie-credits.cast.name`
        - `movie-credits.cast.original_name`
        - `movie-credits.crew.job`
        - `movie-credits.crew.name`
        - `movie-credits.crew.original_name`
        - `movie-credits.crew.department`
        - `movie-credits.crew.known_for_department`
      - Make sure that the following fields are of type `keyword`:
        - `genres.name`
        - `status`
        - `imdb_id`
        - `metadata.class`
        - `metadata.space`
      - **NEVER** make up mapping for fields that do not exist.
        - Example: If a field name is `movie-credits`, **NEVER** convert it to `movie_credits`.
      """
    })
  else
    {:ok, generate_movie_db_index_prompt}
  end

generate_person_db_index_prompt = Memory.get_prompt(movie_db_space, "generate-index-for-person-db-class")

{:ok, generate_person_db_index_prompt} =
  if is_nil(generate_person_db_index_prompt) do
    Memory.create_prompt(movie_db_space, %{
      name: "Generate Index for Person DB Class",
      role: :user,
      content: ~S"""
      ## Person DB Specific Constraints
      - The ID should be of the type `long`.
      - Make sure that the following fields are of type `nested`:
        - `person-combined-credits`
        - `person-combined-credits.cast`
        - `person-combined-credits.crew`
      - Make sure that the following fields are of type `date`:
        - `deathday`
        - `birthday`
        - `person-combined-credits.cast.release_date`
        - `person-combined-credits.crew.release_date`
      - Make sure that the following fields are of type `text`:
        - `name`
        - `biography`
        - `also_known_as`
        - `person-combined-credits.crew.overview`
        - `person-combined-credits.cast.overview`
      - Make sure that the following fields are of type `keyword`:
        - `known_for_department`
        - `imdb_id`
        - `metadata.class`
        - `metadata.space`
        - `person-combined-credits.crew.media_type`
        - `person-combined-credits.cast.media_type`
      - **NEVER** make up mapping for fields that do not exist.
        - Example: If a field name is `person-combined-credits`, **NEVER** convert it to `person_combined_credits`.
      """
    })
  else
    {:ok, generate_person_db_index_prompt}
  end

index_generation_class =
  Neural.get_class(indexing_space, "index-generation")
  |> Repo.preload([:main_corpus])

{:ok, index_generation_class} =
  if is_nil(index_generation_class) do
    Neural.create_class(indexing_space, index_generation_schema)
  else
    {:ok, index_generation_class}
  end


sample_for_movie_indexing_chain = Perception.get_chain(movie_db_space, "sample-for-movie-index-generation")

{:ok, sample_for_movie_indexing_chain} =
  if is_nil(sample_for_movie_indexing_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Sample for Movie Index Generation",
      thoughts: [
        %{
          relation: "sample",
          output_class_id: collection_class.id,
          module: %{
            reference: "tama/classes/sample",
            parameters: %{}
          },
          paths: [
            %{
              target_class_id: movie_detail_class.id,
              parameters: %{
                limit: 3,
                ensure_chunk_exists: true,
                preload: %{
                  concept: %{
                    relations: ["description", "overview", "setting"],
                    embeddings: :metadata,
                    content: %{
                      action: :merge,
                      merge: %{
                        location: :root
                      }
                    }
                  },
                  children: [
                    %{class: "movie-credits", as: :object}
                  ]
                }
              }
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward",
            parameters: %{}
          },
          paths: [
            %{target_class_id: index_generation_class.id}
          ],
          contexts: [
            %{prompt_id: generate_movie_db_index_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, sample_for_movie_indexing_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    class_proxy_class,
    sample_for_movie_indexing_chain,
    %{type: :explicit}
  )

sample_for_person_indexing_chain = Perception.get_chain(movie_db_space, "sample-for-person-index-generation")

{:ok, sample_for_person_indexing_chain} =
  if is_nil(sample_for_person_indexing_chain) do
    Perception.create_chain(movie_db_space, %{
      name: "Sample for Person Index Generation",
      thoughts: [
        %{
          relation: "sample",
          output_class_id: collection_class.id,
          module: %{
            reference: "tama/classes/sample",
            parameters: %{}
          },
          paths: [
            %{
              target_class_id: person_detail_class.id,
              parameters: %{
                limit: 3,
                ensure_chunk_exists: true,
                preload: %{
                  concept: %{
                    relations: ["biography"],
                    embeddings: :metadata,
                    content: %{
                      action: :merge,
                      merge: %{
                        location: :root
                      }
                    }
                  },
                  children: [
                    %{class: "person-combined-credits", as: :object}
                  ]
                }
              }
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward",
            parameters: %{}
          },
          paths: [
            %{target_class_id: index_generation_class.id}
          ],
          contexts: [
            %{prompt_id: generate_person_db_index_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, sample_for_person_indexing_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    movie_db_space,
    class_proxy_class,
    sample_for_person_indexing_chain,
    %{type: :explicit}
  )

index_mapping_generation_prompt = Memory.get_prompt(indexing_space, "index-mapping-generation")

{:ok, index_mapping_generation_prompt} =
  if is_nil(index_mapping_generation_prompt) do
    Memory.create_prompt(indexing_space, %{
      name: "Index Mapping Generation",
      role: :user,
      content: ~S"""
      You are and elasticsearch expert provided with some sample data collection.
      Use the sample data to generate the best elasticsearch mapping for the data.

      ## General Constraints
      - The mapping MUST support vector search if the sample data contains vector embeddings.
      - The vector dimensions are also provided please use the provided value for specifying the dims.
      - Do not create mappings for the vector dimensions metadata.
      - Make sure that fields like `metadata.class`, `metadata.space` are of type `keyword`.
      - Make sure that `preload.concept.content.merge` is of the type `text`.
      - The mapping must be compliant with elasticsearch version 8
      - Do not make a mapping for objects that have `"mapping"` set to `false` inside the object.
      - If a field has `'embedding'`, refer to `metadata.chunks.embedding.dimensions` for the full dimensions count.
        - Example:
          **Data:**
          ```json
          {
            "concepts": [{
              "chunks": [
                {"embedding": [0.0, 0.02]}
              ],
              "metadata": {
                "mapping": false,
                "chunks": {
                  "embedding": {
                    "dimensions": 1024
                  }
                }
              }
            }]
          }
          ```

          **Expected Mapping:**
          ```json
          {
            "concepts": {
              "type": "object",
              "properties": {
                "chunks": {
                  "type": "nested",
                  "properties": {
                    "embedding": {
                      "type": "dense_vector",
                      "dims": 1024
                    }
                  }
                }
              }
            }
          }
          ```
      - Make sure that the following fields are of type `nested`:
        - `concepts.chunks`

      --

      {{ corpus }}
      """
    })
  else
    {:ok, index_mapping_generation_prompt}
  end


dynamic_class = Global.class!("dynamic")

remove_index_alias_template =
  """
  {
    "body": {
      "actions": [
        {
          "remove": {
            "index": "tama-{{ data.sample.space }}-{{ data.sample.name }}-*",
            "alias": "tama-{{ data.sample.space }}-{{ data.sample.name }}"
          }
        }
      ]
    }
  }
  """

remove_index_alias_corpus = Neural.get_corpus(dynamic_class, "remove-index-alias-request")

{:ok, remove_index_alias_corpus} =
  if is_nil(remove_index_alias_corpus) do
    Neural.create_corpus(dynamic_class, %{
      name: "Remove Index Alias Request",
      template: remove_index_alias_template
    })
  else
    {:ok, remove_index_alias_corpus}
  end

create_index_template =
  """
  {
    "path": {
      "index": "tama-{{ data.sample.space }}-{{ data.sample.name }}-{{ data.sample.created_at }}"
    },
    "body": {
      "aliases": {
        "tama-{{ data.sample.space }}-{{ data.sample.name }}": {
          "is_write_index": true
        }
      },
      "mappings": {{ data.mappings.mappings | json }}
    }
  }
  """

create_index_corpus = Neural.get_corpus(dynamic_class, "create-index-request")

{:ok, create_index_corpus} =
  if is_nil(create_index_corpus) do
    Neural.create_corpus(dynamic_class, %{
      name: "Create Index Request",
      template: create_index_template
    })
  else
    {:ok, create_index_corpus}
  end

action = Repo.get_by(Action, specification_id: elasticsearch_specification.id, path: "/{index}")

aliases_action = Repo.get_by(Action, specification_id: elasticsearch_specification.id, path: "/_aliases")

index_generation_chain = Perception.get_chain(indexing_space, "index-generation")

import_and_merge_initializers = [
  %{
    reference: "tama/initializers/import",
    class_id: index_generation_class.id,
    parameters: %{
      resources: [
        %{type: :concept, property: "forwarded_from_concept_id"}
      ]
    }
  },
  %{
    reference: "tama/initializers/merge",
    class_id: index_generation_class.id,
    parameters: %{
      relations: ["mappings", "sample"]
    }
  }
]

action_call_class = Global.class!("action-call")

{:ok, index_generation_chain} =
  if is_nil(index_generation_chain) do
    Perception.create_chain(indexing_space, %{
      name: "Index Generation",
      thoughts: [
        %{
          relation: "mappings",
          initializers: [
            %{
              reference: "tama/initializers/import",
              class_id: index_generation_class.id,
              parameters: %{
                resources: [
                  %{type: :concept, property: "forwarded_from_concept_id"}
                ]
              }
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: grok_3_mini.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          module: %{
            reference: "tama/agentic/generate",
            parameters: %{}
          },
          output_class_id: elasticsearch_mapping_class.id,
          contexts: [
            %{
              prompt_id: index_mapping_generation_prompt.id,
              inputs: [
                %{type: :concept, class_corpus_id: collection_corpus.id}
              ]
            }
          ]
        },
        %{
          relation: "unassign-alias",
          initializers: import_and_merge_initializers,
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: remove_index_alias_corpus.id
            }
          },
          tools: [
            %{action_id: aliases_action.id}
          ]
        },
        %{
          relation: "create-index",
          initializers: import_and_merge_initializers,
          output_class_id: action_call_class.id,
          module: %{
            reference: "tama/actions/caller",
            parameters: %{},
            input: %{
              type: :entity, class_corpus_id: create_index_corpus.id
            }
          },
          tools: [
            %{action_id: action.id}
          ]
        }
      ]
    })
  else
    {:ok, index_generation_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    indexing_space,
    index_generation_class,
    index_generation_chain,
    %{type: :reactive}
  )


````

```elixir
bot = Tama.Global.bot()

movie_detail_class = Repo.preload(movie_detail_class, [proxy: [:entity]])

movie_detail_class.proxy.entity
|> Eventful.Transit.perform(bot, "process",
  parameters: %{
    chain_ids: [sample_for_movie_indexing_chain.id]
  }
)

# person_detail_class = Repo.preload(person_detail_class, [proxy: [:entity]])

# person_detail_class.proxy.entity
# |> Eventful.Transit.perform(bot, "process",
#   parameters: %{
#     chain_ids: [sample_for_person_indexing_chain.id]
#   }
# )

```

## Media Conversation Chains

````elixir
browse_media_prompt = Memory.get_prompt(media_conversation_space, "browse-media")

{:ok, browse_media_prompt} =
  if is_nil(browse_media_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Browse Media",
      role: :system,
      content: """
      You are an elasticsearch querying expert.

      ## Objectives
      - Use the tool provided to query for the movie that best fits the user's query.
      - Select only the relevant properties to put in the _source field of the query.

      ## Constraints
      - The `search-index_text-based-vector-search` vector search tool cannot sort.
      - If you wish to sort you will need to use the `search-index_query-and-sort-based-search`.

      ## Sorting & Cross Index Data Querying
      - You can pass the IDs from `search-index_text-based-vector-search` or from `person-combined-credits.cast.id` or `person-combined-credits.crew.id` into `search-index_query-and-sort-based-search` to sort.
        Example:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "terms": {
                "id": [1234, 7876]
              }
            },
            "sort": [
              {
                "rating": {
                  "order": "desc"
                }
              }
            ],
            "_source": ["id", "title", "poster_path", "overview"]
          }
        }
        ```
        Example with person IDs from in context data  with `_source.person-combined-credits`:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "terms": {
                "id": [348, 313]
              }
            },
            "sort": [
              {
                "release_date": {
                  "order": "desc"
                }
              }
            ],
            "_source": ["id", "title", "poster_path", "overview"]
          }
        }
        ```
        In this example, IDs like `313` and `348` can come from `person-combined-credits.cast.id` or `person-combined-credits.crew.id`, such as:
        ```json
        "_source": {
          "person-combined-credits": {
            "cast": [
              {
                "character": "Linda",
                "media_type": "movie",
                "release_date": "2006-09-08",
                "id": 313,
                "title": "Snow Cake"
              },
              {
                "character": "Ripley",
                "media_type": "movie",
                "release_date": "1979-05-25",
                "id": 348,
                "title": "Alien"
              }
            ]
          }
        }
        ```

      ## Query Generation Guidance
      The `search-index_text-based-vector-search` supports natural language querying.

      To generate a high-quality Elasticsearch query with a natural language query:
      1. **Preserve User Intent in Natural Language**:
        - Create a natural language query that closely matches the user's input, rephrasing only for clarity or to improve search relevance.
        - For example, if the user inputs "movies that take place in the sea or the ocean," the natural language query could be "movies set in the sea or ocean."

      ## Important
      - You will be provided with an index definition that tells you what the index name is and the definition of each of the property.
      - Use the definition to help you choose the property relevant to the search.
      - You will always need the `poster_path`, `id`, `title`, `overview` be sure to include them in the `_source`.
      - NEVER make up properties for the query, ONLY use existing properties.

      ---

      {{ corpus }}
      """
    })
  else
    {:ok, browse_media_prompt}
  end

media_browsing_reply_prompt = Memory.get_prompt(media_conversation_space, "media-browsing-reply-prompt")

{:ok, media_browsing_reply_prompt} =
  if is_nil(media_browsing_reply_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Media Browsing Reply Prompt",
      role: :system,
      content: ~S"""
      You are an assistant tasked with generating a response based on provided media data from a database. Follow these instructions exactly to create a reply:

      - **Data Usage**:
        - Use *only* the data provided in the context. Do not invent, assume, or add any information not explicitly included in the context.
        - Preserve all numerical values (e.g., IDs, ratings, dates) exactly as provided without rounding, modifying, or reformatting them.
        - If a field like `poster_path` is present, use it exactly as provided. If it is null, empty, or missing, follow the instructions under **Response Format**.

      - **Response Format**:
        - Generate the reply in markdown format for clear and consistent rendering.
        - If there is a single result returned in the response, render the result in standard markdown in the following order:
          1. **Poster**: Display the poster image using markdown image syntax: `![Poster](URL)`. Construct the URL by prepending `https://image.tmdb.org/t/p/w500` to the `poster_path` value from the context. If `poster_path` is null, empty, or missing, use the text "No image available" in the Poster section.
          2. **Title**: Use the `title` or `name` field from the context, exactly as provided.
          3. **Overview**: Use the `overview` field from the context, exactly as provided.
        - If multiple results are present in the context, format them as a markdown table with the following columns:
          1. **Poster**: Display the poster image using markdown image syntax: `![Poster](URL)`. Construct the URL by prepending `https://image.tmdb.org/t/p/w200` to the `poster_path` value from the context. If `poster_path` is null, empty, or missing, use the text "No image available" in the Poster column.
          2. **Title**: Use the `title` or `name` field from the context, exactly as provided.
          3. **Overview**: Use the `overview` field from the context, exactly as provided.
          4. Include additional columns only if specified in the context or query (e.g., `release_date`). Do not add columns not requested.
        - If no results are found in the context, return a markdown message: "No media matching the query was found."
        - Do not include additional text, emojis, or phrases like "Let me know if you'd like more recommendations!" unless explicitly requested in the query.

      - **Error Handling**:
        - If the context is empty or contains no data, return a markdown message: "Could not find the data for the query."
        - If the provided data is incomplete (e.g., missing required fields like `title` or `name`), return a markdown message: "Incomplete data provided. Required fields are missing."
        - Do not generate a table or response with fabricated or placeholder data beyond what is specified (e.g., do not invent titles or images).

      - **Tone and Clarity**:
        - Use a neutral, professional tone suitable for a media browsing assistant.
        - Keep the response concise, directly addressing the query using only the provided data.
        - Avoid creative embellishments, assumptions, or additional commentary not requested in the query.
      """
    })
  else
    {:ok, media_browsing_reply_prompt}
  end

search_media_action =
  Repo.get_by(Action, method: :post, path: "/{index}/_search")
  |> Repo.preload([requests: [:body_class]])

vector_search_request = Enum.find(search_media_action.requests, fn r ->
  r.body_class.name == "text-based-vector-search"
end)

vector_seach_class_template =
  """
  {%- capture vectorize_input -%}
    {"thought_id":"{{ data.metadata.thought_id }}","text":"{{ data.query }}"}
  {%- endcapture -%}
  {
    "retriever": {
      "text_similarity_reranker": {
        "retriever": {
          "knn": {
            "field": "concepts.chunks.embedding",
            "query_vector": {{ vectorize_input | vectorize }},
            "k": 3,
            "num_candidates": 10
          }
        },
        "field": "preload.concept.content.merge",
        "inference_id": "jinaai-rerank",
        "inference_text": "{{ data.query }}",
        "rank_window_size": 100,
        "min_score": 0.3
      }
    },
    "size": {{ data.limit | default: 3 }},
    "_source": {
      "includes": {{ data._source | json }},
      "excludes": ["*.embedding"]
    }
  }
  """


vector_search_class_body_corpus = Neural.get_corpus(vector_search_request.body_class, "vector-search-body")


{:ok, vector_search_class_body_corpus} =
  if is_nil(vector_search_class_body_corpus) do
    Neural.create_corpus(vector_search_request.body_class, %{
      name: "Vector Search Body",
      template: vector_seach_class_template
    })
  else
    {:ok, vector_search_class_body_corpus}
  end

standard_search_request = Enum.find(search_media_action.requests, fn r ->
  r.body_class.name == "query-and-sort-based-search"
end)

standard_search_class_template =
  """
  {
    "query": {{ data.query | json }},
    "sort": {% if data.sort %}{{ data.sort | json }}{% else %}[]{% endif %},
    "size": {{ data.limit | default: 3 }},
    "_source": {
      "includes": {% if data._source %}{{ data._source | json }}{% else %}["id"]{% endif %},
      "excludes": ["*.embedding"]
    }
  }
  """

standard_search_class_body_corpus = Neural.get_corpus(standard_search_request.body_class, "standard-search-body")

{:ok, standard_search_class_body_corpus} =
  if is_nil(standard_search_class_body_corpus) do
    Neural.create_corpus(standard_search_request.body_class, %{
      name: "Standard Search Body",
      template: standard_search_class_template
    })
  else
    {:ok, standard_search_class_body_corpus}
  end

Neural.create_bridge(media_conversation_space, %{target_space_id: movie_db_space.id})
Neural.create_bridge(media_conversation_space, %{target_space_id: prompt_assembly_space.id})

browse_media_chain = Perception.get_chain(media_conversation_space, "browse-media-chain")

{:ok, browse_media_chain} =
  if is_nil(browse_media_chain) do
    Perception.create_chain(media_conversation_space, %{
      name: "Browse Media Chain",
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          relation: "tooling",
          contexts: [
            %{
              prompt_id: browse_media_prompt.id,
              inputs: [
                %{type: :metadata, class_corpus_id: base_context_metadata_corpus.id},
                %{type: :concept, class_corpus_id: index_definition_corpus.id}
              ]
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: completion_model.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          tools: [
            %{
              action_id: search_media_action.id,
              initializers: [
                %{
                  reference: "tama/initializers/import",
                  parameters: %{
                    resources: [
                      %{type: :concept, relation: "movie-details-definition", scope: :space}
                    ]
                  }
                }
              ],
              inputs: [
                %{type: :body, class_corpus_id: vector_search_class_body_corpus.id},
                %{type: :body, class_corpus_id: standard_search_class_body_corpus.id}
              ],
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: media_browsing_reply_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, browse_media_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    media_conversation_space,
    media_browsing_class,
    browse_media_chain,
    %{type: :reactive}
  )
````

````elixir
media_detail_prompt = Memory.get_prompt(media_conversation_space, "media-detail")

{:ok, media_detail_prompt} =
  if is_nil(media_detail_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Media Detail",
      role: :system,
      content: """
      You are an Elasticsearch querying expert tasked with retrieving detailed information on specific movie records based on user requests.

      ## Objectives
      - Query Elasticsearch for movie record(s) using the provided `id`(s) or movie title.
      - Select only the relevant properties in the `_source` field based on the index definition and user request.
      - Construct queries that match the users intent, such as retrieving general movie details, cast information, or crew information.
      - Ensure all query components (`query`, `_source`, and optional `sort`) are wrapped inside a `body` object in the JSON output, and include a `path` object specifying the index name from the provided index definition.

      ## Instructions
      ### Querying by ID or Title
      - Use the `search-index_query-and-sort-based-search` tool to query by `id` or movie title and specify properties to retrieve in the `_source` field.
      - **Determine Query Intent**:
        - **General Movie Details**: If the user asks for movie information (e.g., "Details about Moana 2" or "Movies with IDs 1, 2, 3"), use a simple `terms` query for single or multiple IDs.
        - **Cast Related Query**: If the user asks about a character or actor (e.g., "Who played Maui in Moana 2" or "Characters in Moana 2"), use a `nested` query with `movie-credits.cast` and include `inner_hits` for cast details.
        - **Crew Related Query**: If the user asks about crew roles like director, producer, or writer (e.g., "Who is the director of Moana 2" or "Who produced Moana"), use a `nested` query with `movie-credits.crew` and include `inner_hits` for crew details.
        - **Review Related Query**: If the user asks about the review (e.g., "What is the review of Moana 2" or "Moana 2 movie rating") be sure to include `vote_average` and `vote_count` in the `_source`.
        - **Image Related Query**: If the user asks to see images of the media (e.g., "What images do you have on Moana 2" or "Do you have any images I can see?") be sure to include `poster_path` in the `_source`.
      - **Keywords for Intent**:
        - Cast-related: "character," "played," "actor," "actress," "cast."
        - Crew-related: "director," "producer," "writer," "crew," "cinematographer," "composer."
        - General: "movie details," "information," "about," or no specific role mentioned.
        - Rating: "rating", "review".

      ### Query Examples
      #### Single Item Query (General Details)
      **User Query**: "Details about Moana 2" or "Movie with ID 1241982"
        - When the ID is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [1241982]
                }
              },
              "_source": ["id", "title", "vote_average", "release_date"]
            }
          }
          ```
        - When only the media title is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "match": {
                  "title": "Moana 2"
                }
              },
              "limit": 1,
              "_source": ["id", "title", "vote_average", "release_date"]
            }
          }
          ```

      #### Multiple Items Query (General Details)
      **User Query**: "Movies with IDs 1, 2, 3"
      ```json
      {
        "path": {
          "index": "[the index name from the definition]"
        },
        "body": {
          "query": {
            "terms": {
              "id": [1, 2, 3]
            }
          },
          "_source": ["id", "title", "vote_average"]
        }
      }
      ```

      #### Single Item, Cast-Related Query
      **User Query**: "Who played Maui in Moana 2"
        - When the `ID` is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "bool": {
                  "filter": [
                    { "term": { "id": 1241982 } }
                  ],
                  "must": [
                    {
                      "nested": {
                        "path": "movie-credits.cast",
                        "query": {
                          "match": {
                            "movie-credits.cast.character": "*Maui*"
                          }
                        },
                        "inner_hits": {
                          "_source": [
                            "movie-credits.cast.id",
                            "movie-credits.cast.name",
                            "movie-credits.cast.character",
                            "movie-credits.cast.profile_path"
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "_source": ["id", "title"]
            }
          }
          ```
        - When only the media title is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "bool": {
                  "must": [
                    {
                      "match": {
                        "title": "Moana 2"
                      }
                    },
                    {
                      "nested": {
                        "path": "movie-credits.cast",
                        "query": {
                          "match": {
                            "movie-credits.cast.character": "Maui"
                          }
                        },
                        "inner_hits": {
                          "_source": [
                            "movie-credits.cast.id",
                            "movie-credits.cast.name",
                            "movie-credits.cast.character",
                            "movie-credits.cast.profile_path"
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "limit": 1,
              "_source": ["id", "title"]
            }
          }
          ```

      #### Single Item, Crew-Related Query
      **User Query**: "Who is the director of Moana 2"
        - When the `ID` is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "bool": {
                  "filter": [
                    { "term": { "id": 1241982 } }
                  ],
                  "must": [
                    {
                      "nested": {
                        "path": "movie-credits.crew",
                        "query": {
                          "match": {
                            "movie-credits.crew.job": "Director"
                          }
                        },
                        "inner_hits": {
                          "_source": [
                            "movie-credits.crew.id",
                            "movie-credits.crew.name",
                            "movie-credits.crew.job",
                            "movie-credits.crew.profile_path"
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "_source": ["id", "title"]
            }
          }
          ```
        - When only the media title is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "bool": {
                  "must": [
                    {
                      "match": {
                        "title": "Moana 2"
                      }
                    },
                    {
                      "nested": {
                        "path": "movie-credits.crew",
                        "query": {
                          "match": {
                            "movie-credits.crew.job": "Director"
                          }
                        },
                        "inner_hits": {
                          "_source": [
                            "movie-credits.crew.id",
                            "movie-credits.crew.name",
                            "movie-credits.crew.job",
                            "movie-credits.crew.profile_path"
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "limit": 1,
              "_source": ["id", "title"]
            }
          }
          ```

      #### Single Item, Multiple Cast-Related Query
      **User Query**: "Who are the characters in Moana 2"
        - When the `ID` is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "term": {
                  "id": 1241982
                }
              },
              "_source": [
                "id",
                "title",
                "movie-credits.cast.id",
                "movie-credits.cast.name",
                "movie-credits.cast.character",
                "movie-credits.cast.profile_path"
              ]
            }
          }
          ```
        - When only the media title is available in context:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "match": {
                  "title": "Moana 2"
                }
              },
              "limit": 1,
              "_source": [
                "id",
                "title",
                "movie-credits.cast.id",
                "movie-credits.cast.name",
                "movie-credits.cast.character",
                "movie-credits.cast.profile_path"
              ]
            }
          }
          ```

      ### Sorting (Optional)
      - If the user specifies sorting (e.g., "Sort by rating"), include a `sort` object inside the `body` object to order results by a specific field.
        - Example:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [1, 2, 3]
                }
              },
              "sort": [
                {
                  "vote_average": {
                    "order": "desc"
                  }
                }
              ],
              "_source": ["id", "title", "vote_average"]
            }
          }
          ```
      - If the sorting is on a nested field the `nested` `path` needs to be specified in the `sort`:
        - Example:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "bool": {
                  "filter": [
                    { "term": { "id": 1241982 } }
                  ],
                  "must": [
                    {
                      "nested": {
                        "path": "movie-credits.cast",
                        "query": {
                          "match": {
                            "movie-credits.cast.character": "Maui"
                          }
                        },
                        "inner_hits": {
                          "_source": [
                            "movie-credits.cast.id",
                            "movie-credits.cast.name",
                            "movie-credits.cast.character",
                            "movie-credits.cast.profile_path"
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "sort": [
                {
                  "movie-credits.cast.order": {
                    "order": "asc",
                    "nested": {
                      "path": "movie-credits.cast"
                    }
                  }
                }
              ],
              "_source": ["id", "title"]
            }
          }
          ```
      - If there is data in context with the following structure `_source.person-combined-credits.crew` OR `_source.person-combined-credits.cast` you can pass the ID from `_source.person-combined-credits.cast.id` OR `_source.person-combined-credits.crew.id` in to the query like the example below:
        - Example with person IDs from in context data  with `_source.person-combined-credits`:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [348, 313]
                }
              },
              "sort": [
                {
                  "release_date": {
                    "order": "desc"
                  }
                }
              ],
              "_source": ["id", "title", "poster_path", "overview"]
            }
          }
          ```
          In this example, IDs like `313` and `348` can come from `person-combined-credits.cast.id` or `person-combined-credits.crew.id`, such as:
          ```json
          "_source": {
            "person-combined-credits": {
              "cast": [
                {
                  "character": "Linda",
                  "media_type": "movie",
                  "release_date": "2006-09-08",
                  "id": 313,
                  "title": "Snow Cake"
                },
                {
                  "character": "Ripley",
                  "media_type": "movie",
                  "release_date": "1979-05-25",
                  "id": 348,
                  "title": "Alien"
                }
              ]
            }
          }
          ```

      ## Guidelines
      - **Index Definition**: You will receive an index definition specifying the index name and available properties. Use the index name provided in the index definition for the `path` object (e.g., replace "[the index name from the definition]" with the actual index name from the context). Use only the properties available in the index definition for the `_source` field and for sorting.
      - **Property Selection**: Choose properties relevant to the users request based on the index definition. For cast/crew queries, include relevant `inner_hits` fields.
      - **Body Constraints**: There can only ever be a `query`, `_source` and optional `sort`, `limit` in the `body` object. Do not include anything else in the `body object.
      - **Query Efficiency**: Ensure the query retrieves only the requested data to optimize performance.
      - **Title-to-ID Mapping**: If the user provides a movie title (e.g., "Moana 2"), assume the corresponding ID (e.g., 1241982) is provided or retrieved from the index.

      ---

      {{ corpus }}

      ## Important
      - If the user does not specify sorting, omit the `sort` object.
      - Handle both single and multiple ID queries appropriately.
      - You will always need the `poster_path`, `id`, `title`, `overview` be sure to include them in the `_source`.
      - For crew or cast queries, use `match` searches in `nested` queries (e.g., "Director" for crew roles).
      - Ensure all query components (`query`, `_source`, and optional `sort`, `limit`) are always wrapped inside a `body` object, and include a `path` object with the index name from the provided index definition in every response.
      - **NEVER** put the `_source` inside the `query` object. The `_source` is always inside the `body` object.
      - Always replace the index name in the `path` object with the actual index name supplied in the index definition context.
      - When using `_source` with `nested` properties like `movie-credits.cast` or `movie-credits.crew` ALWAYS include the `movie-credits.cast.id` OR `movie-credits.crew.id` in the `_source`.
      - You must **ONLY** use properties mentioned in the `Index Definition` available in the system prompt in the `_source` use only the `values` from previous messages as references in the query.
      """
    })
  else
    {:ok, media_detail_prompt}
  end

media_detail_reply_prompt = Memory.get_prompt(media_conversation_space, "media-detail-reply-prompt")

{:ok, media_detail_reply_prompt} =
  if is_nil(media_detail_reply_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Media Detail Reply Prompt",
      role: :system,
      content: ~S"""
      You are an assistant tasked with generating a response based on provided media data from a database. Follow these instructions exactly to create a reply:

      - **Data Usage**:
        - Use *only* the data provided in the context. Do not invent, assume, or add any information not explicitly included in the context.
        - Preserve all numerical values (e.g., IDs, ratings, dates) exactly as provided without rounding, modifying, or reformatting them.

      - **Response Format**:
        - Generate a reply to the specific detail the user is asking for.
        - Generate the reply in markdown format for clear and consistent rendering.
        - Some results may be nested for example the query about a cast or crew member may come back nested with multiple results make sure you render the results in a markdown table also render the profile picture.
          1. **Profile Picture**: Display the profile picture using markdown image syntax: `![Profile picture](URL)`. Construct the URL by prepending `https://image.tmdb.org/t/p/w200` to the `profile_path` value from the context. If `profile_path` is null, empty, or missing, use the text "No image available" in the Poster column.
          2. **Name**: The name of the cast / crew member
          3. Include additional columns only if specified in the context or query (e.g., `overview`, `release_date`). Do not add columns not requested.
        - If no results are found in the context, return a markdown along the lines of: "I could not find what you are looking for."

      - **Error Handling**:
        - If the context is empty or contains no data, return a markdown message: "I could not find anything based on your query."
        - If the provided data is incomplete (e.g., missing required fields like `title` or `name`), return a markdown message: "Error: Incomplete data provided. Required fields are missing."
        - Do not generate a table or response with fabricated or placeholder data beyond what is specified (e.g., do not invent titles or images).

      - **Tone and Clarity**:
        - Use a neutral, professional tone suitable for a media browsing assistant.
        - Keep the response concise, directly addressing the query using only the provided data.
        - Avoid creative embellishments, assumptions, or additional commentary not requested in the query.
      """
    })
  else
    {:ok, media_detail_reply_prompt}
  end

media_detail_chain = Perception.get_chain(media_conversation_space, "media-detail-chain")

{:ok, media_detail_chain} =
  if is_nil(media_detail_chain) do
    Perception.create_chain(media_conversation_space, %{
      name: "Media Detail Chain",
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          relation: "tooling",
          contexts: [
            %{
              prompt_id: media_detail_prompt.id,
              inputs: [
                %{type: :metadata, class_corpus_id: base_context_metadata_corpus.id},
                %{type: :concept, class_corpus_id: index_definition_corpus.id}
              ]
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: completion_model.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          tools: [
            %{
              action_id: search_media_action.id,
              initializers: [
                %{
                  reference: "tama/initializers/import",
                  parameters: %{
                    resources: [
                      %{type: :concept, relation: "movie-details-definition", scope: :space}
                    ]
                  }
                }
              ],
              inputs: [
                %{type: :body, class_corpus_id: vector_search_class_body_corpus.id},
                %{type: :body, class_corpus_id: standard_search_class_body_corpus.id}
              ],
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: media_detail_reply_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, media_detail_chain}
  end

{:ok, _node} =
  Neural.get_or_create_node(
    media_conversation_space,
    media_detail_class,
    media_detail_chain,
    %{type: :reactive}
  )
````

## People Conversation Chains

````elixir
browse_people_prompt = Memory.get_prompt(media_conversation_space, "browse-people")

{:ok, browse_people_prompt} =
  if is_nil(browse_people_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Browse People",
      role: :system,
      content: """
      You are an Elasticsearch querying expert.

      ## Objectives
      - Use the tool provided to query for the person that best fits the user's query.
      - Select only the relevant properties to put in the `_source` field of the query.

      ## Constraints
      - The `search-index_text-based-vector-search` vector search tool cannot sort.
      - If you wish to sort, you will need to use the `search-index_query-and-sort-based-search`.

      ## Sorting
      - You can pass the IDs from `search-index_text-based-vector-search` into `search-index_query-and-sort-based-search` to sort.
        Example:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "terms": {
                "id": [1, 2, 3]
              }
            },
            "sort": [
              {
                "popularity": {
                  "order": "desc"
                }
              }
            ],
            "_source": ["id", "name"]
          }
        }
        ```
      ## Cross Index Querying
      - You can pass the IDs from `_source.movie-credits.cast.id` OR `_source.movie-credits.crew.id` into the `search-index_query-and-sort-based-search`.
        - Example data in context:
          ```json
          "_source": {
            "movie-credits": {
              "cast": [
                {
                  "id": 996701,
                  "name": "Miles Teller"
                },
                {
                  "id": 1397778,
                  "name": "Anya Taylor-Joy"
                }
              ]
            }
          }
          ```
          The following Query would fetch the record for a given cast or crew member:
          ```json
          {
          "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [996701, 1397778]
                }
              },
              "sort": [
                {
                  "popularity": {
                    "order": "desc"
                  }
                }
              ],
              "_source": ["id", "name", "biography"]
            }
          }
          ```

      ## Query Generation Guidance
      The `search-index_text-based-vector-search` supports natural language querying.

      To generate a high-quality Elasticsearch query with a natural language query:
      1. **Preserve User Intent in Natural Language**:
         - Create a natural language query that closely matches the user's input, rephrasing only for clarity or to improve search relevance.
         - For example, if the user inputs "actors known for directing," the natural language query could be "persons known for directing."

      --

      {{ corpus }}

      ## Important
      - You will be provided with an index definition that tells you what the index name is and the definition of each property.
      - Use the definition to help you choose the properties relevant to the search.
      - You will always need the `profile_path`, `id`, `name`, `biography` properties; be sure to include them in the `_source`.
      - NEVER make up properties for the query, ONLY use existing properties.
      """
    })
  else
    {:ok, browse_people_prompt}
  end

people_browsing_reply_prompt = Memory.get_prompt(media_conversation_space, "people-browsing-reply-prompt")

{:ok, people_browsing_reply_prompt} =
  if is_nil(people_browsing_reply_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "People Browsing Reply Prompt",
      role: :system,
      content: ~S"""
      You are an assistant tasked with generating a response based on provided person data from a database. Follow these instructions exactly to create a reply:

      - **Data Usage**:
        - Use *only* the data provided in the context. Do not invent, assume, or add any information not explicitly included in the context.
        - Preserve all numerical values (e.g., IDs, popularity scores, dates) exactly as provided without rounding, modifying, or reformatting them.
        - If a field like `profile_path` is present, use it exactly as provided. If it is null, empty, or missing, follow the instructions under **Response Format**.

      - **Response Format**:
        - Generate the reply in markdown format for clear and consistent rendering.
        - If there is a single result returned in the response, render the result in standard markdown in the following order:
          1. **Profile Image**: Display the profile image using markdown image syntax: `![Profile Image](URL)`. Construct the URL by prepending `https://image.tmdb.org/t/p/w500` to the `profile_path` value from the context. If `profile_path` is null, empty, or missing, use the text "No image available" in the Profile Image section.
          2. **Name**: Use the `name` field from the context, exactly as provided.
          3. **Biography**: Use the `biography` field from the context, exactly as provided.
        - If multiple results are present in the context, format them as a markdown table with the following columns, rendered strictly in this order:
          1. **Profile Image**: Display the profile image using markdown image syntax: `![Profile Image](URL)`. Construct the URL by prepending `https://image.tmdb.org/t/p/w200` to the `profile_path` value from the context. If `profile_path` is null, empty, or missing, use the text "No image available" in the Profile Image column.
          2. **Name**: Use the `name` field from the context, exactly as provided.
          3. **Biography**: Use the `biography` field from the context, exactly as provided.
          4. Include additional columns only if specified in the context or query (e.g., `birthday`, `known_for_department`). Do not add columns not requested. Ensure additional columns are rendered in the order specified in the context or query, following the primary columns.
        - If no results are found in the context, return a markdown message: "No persons matching the query were found."
        - Do not include additional text, emojis, or phrases like "Let me know if you'd like more information!" unless explicitly requested in the query.

      - **Error Handling**:
        - If the context is empty or contains no data, return a markdown message: "Could not find the data for the query."
        - If the provided data is incomplete (e.g., missing required fields like `name`), return a markdown message: "Incomplete data provided. Required fields are missing."
        - Do not generate a table or response with fabricated or placeholder data beyond what is specified (e.g., do not invent names or images).

      - **Tone and Clarity**:
        - Use a neutral, professional tone suitable for a person data browsing assistant.
        - Keep the response concise, directly addressing the query using only the provided data.
        - Avoid creative embellishments, assumptions, or additional commentary not requested in the query.
      """
    })
  else
    {:ok, people_browsing_reply_prompt}
  end

browse_people_chain = Perception.get_chain(media_conversation_space, "browse-people-chain")

{:ok, browse_people_chain} =
  if is_nil(browse_people_chain) do
    Perception.create_chain(media_conversation_space, %{
      name: "Browse People Chain",
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          relation: "tooling",
          contexts: [
            %{
              prompt_id: browse_people_prompt.id,
              inputs: [
                %{type: :metadata, class_corpus_id: base_context_metadata_corpus.id},
                %{type: :concept, class_corpus_id: index_definition_corpus.id}
              ]
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: completion_model.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          tools: [
            %{
              action_id: search_media_action.id,
              initializers: [
                %{
                  reference: "tama/initializers/import",
                  parameters: %{
                    resources: [
                      %{type: :concept, relation: "person-details-definition", scope: :space}
                    ]
                  }
                }
              ],
              inputs: [
                %{type: :body, class_corpus_id: vector_search_class_body_corpus.id},
                %{type: :body, class_corpus_id: standard_search_class_body_corpus.id}
              ],
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: people_browsing_reply_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, browse_people_chain}
  end

person_browsing_class = Neural.get_class(media_conversation_space, "person-browsing")

{:ok, _} =
  Neural.get_or_create_node(
    media_conversation_space,
    person_browsing_class,
    browse_people_chain,
    %{type: :reactive}
  )

````

````elixir
person_detail_prompt = Memory.get_prompt(media_conversation_space, "person-detail")

{:ok, person_detail_prompt} =
  if is_nil(person_detail_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Person Detail",
      role: :system,
      content: """
      You are an Elasticsearch querying expert tasked with retrieving detailed information on specific person records based on user requests.

      ## Objectives
      - Query Elasticsearch for person record(s) using the provided `id`(s) or person name.
      - Select only the relevant properties in the `_source` field based on the index definition and user request.
      - Construct queries that match the users intent, such as retrieving general person details, biographical information, or department-related information.
      - Ensure all query components (`query`, `_source`, and optional `sort`) are wrapped inside a `body` object in the JSON output, and include a `path` object specifying the index name extracted from the provided index definition.

      ## Instructions
      ### Querying by ID or Name
      - Use the `search-index_query-and-sort-based-search` tool to query by `id` or person name and specify properties to retrieve in the `_source` field.
      - **Determine Query Intent**:
        - **General Person Details**: If the user asks for person information (e.g., "Details about Dwayne Johnson" or "Persons with IDs 1, 2, 3"), use a simple `terms` query for single or multiple IDs.
        - **Department-Related Query**: If the user asks about a persons role or department (e.g., "What department is Dwayne Johnson known for " or "Is Dwayne Johnson a director"), use a `match` query with `known_for_department` and include relevant fields in `_source`.
        - **Biography-Related Query**: If the user asks about a persons biography or background (e.g., "What is Dwayne Johnsons biography" or "Tell me about Dwayne Johnsons life"), include `biography`, `birthday`, `place_of_birth`, and `deathday` (if applicable) in the `_source`.
        - **Image-Related Query**: If the user asks for images of the person (e.g., "What images do you have of Dwayne Johnson" or "Do you have any images I can see?"), include `profile_path` in the `_source`.
        - **Popularity-Related Query**: If the user asks about a persons popularity (e.g., "How popular is Dwayne Johnson" or "Who is the most popular actor"), include `popularity` in the `_source` and optionally sort by `popularity`.
      - **Keywords for Intent**:
        - Department-related: "department," "role," "director," "actor," "producer," "writer."
        - Biography-related: "biography," "background," "life," "born," "birth."
        - General: "details," "information," "about," or no specific role mentioned.
        - Popularity: "popularity," "popular," "famous."
        - Image: "image," "photo," "picture," "profile."
      - **Nested Object ID**:
        - When querying for nested object like `person-combined-credits.crew` or `person-combined-credits.cast` be sure to include the `person-combined-credits.cast.id` and `person-combined-credits.crew.id` in the `_source` field as they can be used in subsequent queries.

      ### Query Examples
      #### Single Item Query (General Details)
      **User Query**: "Details about Dwayne Johnson" or "Person with ID 12345"
      - When the ID is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "terms": {
                "id": [12345]
              }
            },
            "_source": ["id", "name", "known_for_department", "popularity", "profile_path"]
          }
        }
        ```
      - When only the person name is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "match": {
                "name": "Dwayne Johnson"
              }
            },
            "limit": 1,
            "_source": ["id", "name", "known_for_department", "popularity", "profile_path"]
          }
        }
        ```

      #### Single Item query about other movies a given person has been in
      **User Query**: "Which other movie has Dwayne Johnson been in" or "Which other movie has person with ID 12345 been in"
      - When the ID is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "bool": {
                "filter": [
                  {
                    "term": { "id": 12345 }
                  }
                ],
                "must": [
                  {
                    "nested": {
                      "path": "person-combined-credits.cast",
                      "query": {
                        "match": {
                          "person-combined-credits.cast.media_type": "movie"
                        }
                      },
                      "inner_hits": {
                        "size": 100,
                        "sort": {
                          "person-combined-credits.cast.vote_average": {
                            "order": "desc"
                          }
                        },
                        "_source": [
                          "person-combined-credits.cast.id",
                          "person-combined-credits.cast.title",
                          "person-combined-credits.cast.character",
                          "person-combined-credits.cast.release_date",
                          "person-combined-credits.cast.vote_average",
                          "person-combined-credits.cast.media_type",
                          "person-combined-credits.cast.poster_path"
                        ]
                      }
                    }
                  }
                ]
              }
            },
            "_source": [
              "id",
              "name"
            ]
          }
        }
        ```
      - When only the person's name is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "bool": {
                "must": [
                  {
                    "match": {
                      "name": "Dwayne Johnson"
                    }
                  },
                  {
                    "nested": {
                      "path": "person-combined-credits.cast",
                      "query": {
                        "match": {
                          "person-combined-credits.cast.media_type": "movie"
                        }
                      },
                      "inner_hits": {
                        "size": 100,
                        "sort": {
                          "person-combined-credits.cast.vote_average": {
                            "order": "desc"
                          }
                        },
                        "_source": [
                          "person-combined-credits.cast.id",
                          "person-combined-credits.cast.title",
                          "person-combined-credits.cast.character",
                          "person-combined-credits.cast.release_date",
                          "person-combined-credits.cast.vote_average",
                          "person-combined-credits.cast.media_type",
                          "person-combined-credits.cast.poster_path"
                        ]
                      }
                    }
                  }
                ]
              }
            },
            "limit": 1,
            "_source": [
              "id",
              "name"
            ],
          }
        }
        ```

      #### Multiple Items Query (General Details)
      **User Query**: "Persons with IDs 1, 2, 3"
      ```json
      {
        "path": {
          "index": "[the index name from the definition]"
        },
        "body": {
          "query": {
            "terms": {
              "id": [1, 2, 3]
            }
          },
          "_source": ["id", "name", "known_for_department", "popularity", "profile_path"]
        }
      }
      ```

      #### Single Item, Department-Related Query
      **User Query**: "What department is Dwayne Johnson known for"
      - When the ID is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "bool": {
                "filter": [
                  { "term": { "id": 12345 } }
                ],
                "must": [
                  {
                    "match": {
                      "known_for_department": "Acting"
                    }
                  }
                ]
              }
            },
            "_source": ["id", "name", "known_for_department", "profile_path"]
          }
        }
        ```
      - When only the person name is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "bool": {
                "must": [
                  {
                    "match": {
                      "name": "Dwayne Johnson"
                    }
                  },
                  {
                    "match": {
                      "known_for_department": "Acting"
                    }
                  }
                ]
              }
            },
            "limit": 1,
            "_source": ["id", "name", "known_for_department", "profile_path"]
          }
        }
        ```

      #### Single Item, Biography-Related Query
      **User Query**: "What is Dwayne Johnsons biography"
      - When the ID is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "term": {
                "id": 12345
              }
            },
            "_source": ["id", "name", "biography", "birthday", "place_of_birth", "deathday", "profile_path"]
          }
        }
        ```
      - When only the person name is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "match": {
                "name": "Dwayne Johnson"
              }
            },
            "limit": 1,
            "_source": ["id", "name", "biography", "birthday", "place_of_birth", "deathday", "profile_path"]
          }
        }
        ```

      #### Single Item, Image-Related Query
      **User Query**: "What images do you have of Dwayne Johnson"
      - When the ID is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "term": {
                "id": 12345
              }
            },
            "_source": ["id", "name", "profile_path"]
          }
        }
        ```
      - When only the person name is available in context:
        ```json
        {
          "path": {
            "index": "[the index name from the definition]"
          },
          "body": {
            "query": {
              "match": {
                "name": "Dwayne Johnson"
              }
            },
            "limit": 1,
            "_source": ["id", "name", "profile_path", "biography"]
          }
        }
        ```

      ### Sorting (Optional)
      - If the user specifies sorting (e.g., "Sort by popularity"), include a `sort` object inside the `body` object to order results by a specific field.
        - Example:
          ```json
          {
            "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [1, 2, 3]
                }
              },
              "sort": [
                {
                  "popularity": {
                    "order": "desc"
                  }
                }
              ],
              "_source": ["id", "name", "popularity", "profile_path"]
            }
          }
          ```

      ### Cross Index Querying
      - You can pass the IDs from `_source.movie-credits.cast.id` OR `_source.movie-credits.crew.id` into the `search-index_query-and-sort-based-search`.
        - Example data in context:
          ```json
          "_source": {
            "movie-credits": {
              "cast": [
                {
                  "id": 996701,
                  "name": "Miles Teller"
                },
                {
                  "id": 1397778,
                  "name": "Anya Taylor-Joy"
                }
              ]
            }
          }
          ```
          The following Query would fetch the record for a given cast or crew member:
          ```json
          {
          "path": {
              "index": "[the index name from the definition]"
            },
            "body": {
              "query": {
                "terms": {
                  "id": [996701, 1397778]
                }
              },
              "sort": [
                {
                  "popularity": {
                    "order": "desc"
                  }
                }
              ],
              "_source": ["id", "name", "biography"]
            }
          }
          ```

      ## Guidelines
      - **Index Definition**: Extract the index name from the provided index definition (e.g., from the `corpus` or context) and use it in the `path` object by replacing `[the index name from the definition]` with the actual index name (e.g., `tama-movie-db-person-details`). Use only the properties available in the index definition (`adult`, `also_known_as`, `biography`, `birthday`, `deathday`, `gender`, `id`, `imdb_id`, `known_for_department`, `metadata.space`, `metadata.class`, `name`, `parent_entity_id`, `place_of_birth`, `popularity`, `profile_path`, `preload.concept.content.merge`) for the `_source` field and for sorting.
      - **Property Selection**: Choose properties relevant to the users request based on the index definition.
      - **Body Constraints**: There can only ever be a `query`, `_source`, and optional `sort`, `limit` in the `body` object. Do not include anything else in the `body` object.
      - **Query Efficiency**: Ensure the query retrieves only the requested data to optimize performance.
      - **Name-to-ID Mapping**: If the user provides a person name (e.g., "Dwayne Johnson"), assume the corresponding ID (e.g., 12345) is provided or retrieved from the index.
      - **Required Fields**: Always include `id`, `name`, and `profile_path` in the `_source` unless the users intent excludes them.

      ---

      {{ corpus }}

      ## Important
      - If the user does not specify sorting, omit the `sort` object.
      - Handle both single and multiple ID queries appropriately.
      - For department-related queries, use `match` searches for `known_for_department` (e.g., "Acting", "Directing").
      - Ensure all query components (`query`, `_source`, and optional `sort`, `limit`) are always wrapped inside a `body` object, and include a `path` object with the index name extracted from the provided index definition (replacing `[the index name from the definition]` with the actual index name, e.g., `tama-movie-db-person-details`).
      - **NEVER** put the `_source` inside the `query` object. The `_source` is always inside the `body` object.
      - Always infer the index name from the provided index definition in the `corpus` or context and use it in the `path` object.
      """
    })
  else
    {:ok, person_detail_prompt}
  end

person_detail_reply_prompt = Memory.get_prompt(media_conversation_space, "person-detail-reply-prompt")

{:ok, person_detail_reply_prompt} =
  if is_nil(person_detail_reply_prompt) do
    Memory.create_prompt(media_conversation_space, %{
      name: "Person Detail Reply Prompt",
      role: :system,
      content: ~S"""
      You are an assistant tasked with generating a response based on provided media data from a database. Follow these instructions exactly to create a reply:

      - **Data Usage**:
        - Use _only_ the data provided in the context. Do not invent, assume, or add any information not explicitly included in the context.
        - Preserve all numerical values (e.g., IDs, ratings, dates) exactly as provided without rounding, modifying, or reformatting them.

      - **Response Format**:
        - Generate a reply to the specific detail the user is asking for.
        - Generate the reply in markdown format for clear and consistent rendering.
        - For queries about cast or crew members, if multiple results are provided (e.g., nested results), render the results in a markdown table with the following columns:
          1. **Profile Picture**: Display the profile picture using markdown image syntax: `![Profile picture](https://image.tmdb.org/t/p/w200<profile_path>)`. If `profile_path` is null, empty, or missing, use the text "No image available" in the Profile Picture column.
          2. **Name**: The `name` of the cast or crew member (text).
          3. Include additional columns only if specified in the context or query (e.g., `biography`, `birthday`, `known_for_department`). Do not add columns not requested.
        - If no results are found in the context, return a markdown message: "I could not find what you are looking for."

      - **Error Handling**:
        - If the context is empty or contains no data, return a markdown message: "I could not find anything based on your query."
        - If the provided data is incomplete (e.g., missing required fields like `name` for a person), return a markdown message: "Error: Incomplete data provided. Required fields are missing."
        - Do not generate a table or response with fabricated or placeholder data beyond what is specified (e.g., do not invent names or images).

      - **Tone and Clarity**:
        - Use a neutral, professional tone suitable for a media browsing assistant.
        - Keep the response concise, directly addressing the query using only the provided data.
        - Avoid creative embellishments, assumptions, or additional commentary not requested in the query.
      """
    })
  else
    {:ok, person_detail_reply_prompt}
  end

person_detail_chain = Perception.get_chain(media_conversation_space, "person-detail-chain")

{:ok, person_detail_chain} =
  if is_nil(person_detail_chain) do
    Perception.create_chain(media_conversation_space, %{
      name: "Person Detail Chain",
      thoughts: [
        %{
          module: %{
            reference: "tama/agentic/tooling", parameters: %{}
          },
          relation: "tooling",
          contexts: [
            %{
              prompt_id: person_detail_prompt.id,
              inputs: [
                %{type: :metadata, class_corpus_id: base_context_metadata_corpus.id},
                %{type: :concept, class_corpus_id: index_definition_corpus.id}
              ]
            }
          ],
          processors: [
            %{
              type: :completion,
              model_id: completion_model.id,
              configuration: %{
                temperature: 0.0
              }
            }
          ],
          tools: [
            %{
              action_id: search_media_action.id,
              initializers: [
                %{
                  reference: "tama/initializers/import",
                  parameters: %{
                    resources: [
                      %{type: :concept, relation: "person-details-definition", scope: :space}
                    ]
                  }
                }
              ],
              inputs: [
                %{type: :body, class_corpus_id: vector_search_class_body_corpus.id},
                %{type: :body, class_corpus_id: standard_search_class_body_corpus.id}
              ],
            }
          ]
        },
        %{
          relation: "forwarding",
          module: %{
            reference: "tama/concepts/forward", parameters: %{}
          },
          paths: [
            %{target_class_id: context_component_class.id}
          ],
          contexts: [
            %{prompt_id: person_detail_reply_prompt.id}
          ]
        }
      ]
    })
  else
    {:ok, person_detail_chain}
  end

person_detail_class = Neural.get_class(media_conversation_space, "person-detail")

{:ok, _} =
  Neural.get_or_create_node(
    media_conversation_space,
    person_detail_class,
    person_detail_chain,
    %{type: :reactive}
  )

````
